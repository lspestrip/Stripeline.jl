<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Scanning strategy · Stripeline.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="https://threejs.org/build/three.js"></script><script src="../assets/OrbitControls.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Stripeline.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../basic/">Basic functions</a></li><li><a class="tocitem" href="../instrumentdb/">Instrument database</a></li><li class="is-active"><a class="tocitem" href>Scanning strategy</a><ul class="internal"><li><a class="tocitem" href="#Strip&#39;s-location-and-movements-1"><span>Strip&#39;s location and movements</span></a></li><li><a class="tocitem" href="#Simulating-the-motion-of-the-telescope-wheels-1"><span>Simulating the motion of the telescope wheels</span></a></li><li><a class="tocitem" href="#A-more-complex-example-1"><span>A more complex example</span></a></li><li><a class="tocitem" href="#A-more-complex-example-2"><span>A more complex example</span></a></li><li><a class="tocitem" href="#Reference-documentation-1"><span>Reference documentation</span></a></li></ul></li><li><a class="tocitem" href="../acquisition/">Data acquisition</a></li><li><a class="tocitem" href="../mapmaking/">Map making</a></li><li><a class="tocitem" href="../simulation_tutorial/">Full-scale simulation tutorial</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Scanning strategy</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Scanning strategy</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lspestrip/Stripeline.jl/blob/master/docs/src/scanning.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Simulating-the-scanning-strategy-1"><a class="docs-heading-anchor" href="#Simulating-the-scanning-strategy-1">Simulating the scanning strategy</a><a class="docs-heading-anchor-permalink" href="#Simulating-the-scanning-strategy-1" title="Permalink"></a></h1><p>Stripeline includes a set of tools to simulate the observation of the sky by the telescope. The way a telescope observes the sky is called <em>scanning strategy</em>, and it is obviously one of the most basic and important task in any simulation of data taking.</p><h2 id="Strip&#39;s-location-and-movements-1"><a class="docs-heading-anchor" href="#Strip&#39;s-location-and-movements-1">Strip&#39;s location and movements</a><a class="docs-heading-anchor-permalink" href="#Strip&#39;s-location-and-movements-1" title="Permalink"></a></h2><p>The Strip telescope, unlike most of the optical telescopes, performs a regular, uninterrupted movement using the so-called <em>azimuth motor</em>, a wheel that makes the whole structure spin around its gravity axis. The height of the telescope can be varied by another motor (the <em>altitude motor</em>), but we foresee that it will be always kept at the same angle during spinning. The following animation shows how the two motor operates: first, the altitude motor moves by roughly 20°, and then the azimuth motor starts spinning.</p><iframe
    src="https://www.youtube.com/embed/01P_5aCmST0"
    frameborder="0"
    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen>
</iframe><p>The red laser beam shows the so-called <em>boresight direction</em>, which points toward the position being observed on the celestial sphere. The motion of the telescope, coupled with the spinning of the Earth, produces a characteristic pattern in the sequence of points on the celestial sphere that are observed by Strip. To understand this pattern, you must be aware that Strip will be deployed to Tenerife, one of the Canarian Islands (Spain), a location in the Northern Emisphere, at latitude ≈28°N:</p><iframe
    width="425"
    height="350"
    frameborder="0"
    scrolling="no"
    marginheight="0"
    marginwidth="0"
    src="https://www.openstreetmap.org/export/embed.html?bbox=-16.525948047637943%2C28.29287470104711%2C-16.497623920440677%2C28.309538133052932&amp;layer=mapnik"
    style="border: 1px solid black">
</iframe>
<br/>
<small>
    <a href="https://www.openstreetmap.org/#map=16/28.3012/-16.5118">Enlarged map</a>
</small><p>(The coordinates of the site, as well as its elevation, are available in the constants <a href="#Stripeline.TENERIFE_LATITUDE_DEG"><code>TENERIFE_LATITUDE_DEG</code></a>, <a href="#Stripeline.TENERIFE_LONGITUDE_DEG"><code>TENERIFE_LONGITUDE_DEG</code></a>, and <a href="#Stripeline.TENERIFE_HEIGHT_M"><code>TENERIFE_HEIGHT_M</code></a>.) Now, consider the animation of the spinning telescope as seen from space:</p><iframe
    src="https://www.youtube.com/embed/WKibmFWynbM"
    frameborder="0"
    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen>
</iframe><p>As above, the red vector shows the boresight direction, while the green vector shows the zenith at Tenerife (the direction along the gravitational force vector, pointings towards the sky); the yellow direction represents the direction of the beam polarizer, and it is a parameter used to convert the <a href="https://en.wikipedia.org/wiki/Stokes_parameters">Stokes parameters</a> <span>$Q$</span> and <span>$U$</span> to celestial coordinates. Remembering that the red beam shows where the telescope is looking, this scanning strategy observes a circumference in the sky. However, because Earth rotates once every 24 hours (much faster in the animation than in reality!), the observation pattern is a spiral that covers a «strip» on the sky, whose apparent height is roughly equal to twice the angle of the boresight wheel.</p><h2 id="Simulating-the-motion-of-the-telescope-wheels-1"><a class="docs-heading-anchor" href="#Simulating-the-motion-of-the-telescope-wheels-1">Simulating the motion of the telescope wheels</a><a class="docs-heading-anchor-permalink" href="#Simulating-the-motion-of-the-telescope-wheels-1" title="Permalink"></a></h2><p>We&#39;ll now use the tools provided by Stripeline to simulate the region of the sky that is observed by the telescope. You can type the following commands in a Jupyter notebook, if you have installed the awesome <a href="https://github.com/JuliaLang/IJulia.jl">IJulia</a> package; otherwise, you can write them directly on Julia&#39;s command line. Let&#39;s load the packages we&#39;ll need to run the simulation: <a href="https://github.com/JuliaPlots/Plots.jl">Plots</a> enables the <code>plot</code> function, <a href="https://github.com/ziotom78/Healpix.jl">Healpix</a> implements the Healpix tessellation algorithm on the sphere, and yours truly Stripeline:</p><pre><code class="language-">using Plots
using Healpix
using Stripeline</code></pre><p>Since Stripeline is a simulator, it has been designed to be extremely versatile: the angles of the two wheels discussed above (the elevation wheel and the azimuth wheel) can be specified as arbitrary functions of time, expressed in seconds:</p><pre><code class="language-julia">telescope_motors(time_s) = (0.0, deg2rad(20.0), timetorotang(time_s, 1))</code></pre><p>Here we use the handy function <a href="#Stripeline.timetorotang"><code>timetorotang</code></a> to compute <span>$2\pi\nu t$</span>, the angle as a function of time for a continuous circular motion of 1 rotation per minute. This function must be passed as the first parameter to the function <a href="#Stripeline.genpointings"><code>genpointings</code></a>, which computes the direction and the observing angle for a number of points in time. The direction is encoded as a <span>$N\times 2$</span> matrix containing the colatitude and the longitude in the two columns; we iterate on the <span>$N$</span> rows of this matrix and set each pixel in a Healpix map to this value, taking advantage of Healpix.jl&#39;s function <code>ang2pix</code>:</p><pre><code class="language-julia">function project_to_map(time_range, map)
    # We discard the second return value of &quot;genpointings&quot; with &quot;_&quot;:
    # it&#39;s the orientation, but for this simple example it is not necessary
    dirs, _ = genpointings(
        telescope_motors,  # Angle of the three wheels as a function of time
        Float64[0, 0, 1],  # Observing direction in the focal plane reference frame
        time_range,        # Array of time values
    )

    # For each sample, set the corresponding pixel in the sky map to 1
    for idx in 1:length(time_range)
        # Extract the colatitude and the longitude from &quot;dirs&quot;
        colat, long = dirs[idx, :]
        pixel_index = ang2pix(map, colat, long)
        map[pixel_index] = 1
    end
end</code></pre><p>It&#39;s now a matter of creating a Healpix map, wrapping the code in a call to <code>project_to_map</code>, and plotting the result:</p><pre><code class="language-"># We create a Healpix map that represents the whole sky sphere,
# tessellated up to some resolution NSIDE=128
map = Healpix.Map{Float64, RingOrder}(128)

# Set the sampling time, the number of seconds used to create one
# measurement. The real value is 0.01, but we use a larger
# sampling time to make the simulation faster
sampling_time_s = 0.05

# Run a simulation lasting one minute (which corresponds to
# exactly one rotation of the telescope around the azimuth axis)
project_to_map(0.0:sampling_time_s:60.0, map)

# Plot the map, using the orthographic projection
plot(map, orthographic)
savefig(&quot;oneminutemap.svg&quot;); nothing # hide</code></pre><p><img src="oneminutemap.svg" alt/></p><p>The result should match your expectations: considering the animation of the spinning telescope as seen from space, the sequence of points set to 1 in the map corresponds to the directions visited by the red vector during <em>one</em> spin. Let&#39;s re-run the animation over a longer time span, one hour; no need to re-allocate the map, as we&#39;ll simply overwrite it:</p><pre><code class="language-"># Run a simulation lasting one hour (60 rotations
# of the telescope, while the Earth slowly spins)
project_to_map(0.0:sampling_time_s:3600.0, map)

plot(map, orthographic)
savefig(&quot;onehourmap.svg&quot;); nothing # hide</code></pre><p><img src="onehourmap.svg" alt/></p><p>Running the simulation over one hour shows the effect of the Earth&#39;s rotation, which makes the circle move Eastward.</p><h2 id="A-more-complex-example-1"><a class="docs-heading-anchor" href="#A-more-complex-example-1">A more complex example</a><a class="docs-heading-anchor-permalink" href="#A-more-complex-example-1" title="Permalink"></a></h2><p>In the examples above, we set to 1 the pixels in the map that were observed by the Strip telescope at least one time. A much more informative way of plotting these maps is to <em>count</em> the number of times a pixel has been observed, as typically one wants to make several observations and then average them together to produce one estimate with its own error bar. The number stored in each pixel is the so-called <em>hit count</em> for that pixel, and it is related to the overall amount of time spent by the telescope observing that direction.</p><p>Let&#39;s modify the function <code>project_to_map</code> so that it increments the value of a pixel:</p><pre><code class="language-julia">function project_to_map(time_range, map)
    dirs, _ = genpointings(telescope_motors, Float64[0, 0, 1], time_range)

    for idx in 1:length(time_range)
        colat, long = dirs[idx, :]
        pixel_index = ang2pix(map, colat, long)

        # Increment the &quot;hit count&quot;
        map[pixel_index] += 1
    end
end</code></pre><p>Now let&#39;s recreate the simulation above, using the <code>@animate</code> macro to produce a movie of the hit count as time passes:</p><pre><code class="language-"># Reset the map, so that each pixel is set to zero
map[:] .= 0

# Create one frame per each minute of observation
anim = @animate for minute in 0:60
    # Start and end times of this minute; note that we drop
    # the last sample from &quot;end_time_s&quot;, as it will be included
    # in the next iteration
    start_time_s = minute * 60
    end_time_s = (minute + 1) * 60 - sampling_time_s

    project_to_map(start_time_s:sampling_time_s:end_time_s, map)

    # The keyword &quot;clim&quot; fixes the lower and upper limits of the
    # color bar. Avoiding to do so results in the color scale flickering
    # between frames in the animation (try it!)
    plot(map, orthographic, clim=(0, 100))
end

# Save the result into an animated GIF file, with 10 frames per second.
# As one frame in our animation lasts one minute, this means that each
# second in the animation corresponds to 10 minutes
gif(anim, &quot;scanning-animation.gif&quot;, fps = 10)</code></pre><p>Note that most of the pixels are observed a few times, but those on the uppermost and lowermost part of the strip have a much higher hit count. We clipped the maximum value shown in the color bar to 100, but we can make Julia compute the maximum value in the map:</p><pre><code class="language-">println(&quot;The maximum hit count in the map is &quot;, maximum(map))</code></pre><h2 id="A-more-complex-example-2"><a class="docs-heading-anchor" href="#A-more-complex-example-2">A more complex example</a><a class="docs-heading-anchor-permalink" href="#A-more-complex-example-2" title="Permalink"></a></h2><p>So far, we have simulated the behavior of the Strip instrument in quite ideal conditions: we started each simulation from time <span>$t = 0$</span>, without specifying an absolute date.</p><p>The function <a href="#Stripeline.genpointings"><code>genpointings</code></a> accepts a starting time expressed as a <a href="https://en.wikipedia.org/wiki/Julian_day">Julian date</a>; in this case, it uses a slower algorithm to find the direction and orientation of the telescope that considers several other effects:</p><ol><li>The position of the Earth with respect to the Sun;</li><li>The <a href="https://en.wikipedia.org/wiki/Axial_precession">precession of the Earth&#39;s  axis</a>;</li><li>The  <a href="https://en.wikipedia.org/wiki/Astronomical_nutation">nutation</a> of  the Earth&#39;s axis due to other bodies in the Solar System;</li><li><a href="https://en.wikipedia.org/wiki/Aberration_(astronomy)">Stellar aberration</a>;</li><li><a href="https://en.wikipedia.org/wiki/Atmospheric_refraction">Atmospheric  refraction</a>,  although this computation is valid only for visible wavelengths  and should therefore not be used when simulating observations done  by Strip detectors (which operates at microwave lengths).</li></ol><p>To specify times, you can use the functions <code>jdcnv</code> and <code>daycnv</code> from <a href="https://github.com/JuliaAstro/AstroLib.jl">AstroLib</a>:</p><pre><code class="language-julia">using AstroLib, Dates

# Convert the date January, 1st 2022, 15:00:00 to a Julian date
start_day = DateTime(2022, 1, 1, 15, 0, 0))

println(&quot;The simulation starts from JD $start_day&quot;)

dirs, orientations = genpointings(
    telescope_motors,
    Float64[0, 0, 1],
    0:sampling_time_s:60.0,
    start_day,   # We specify here the JD when the simulation starts
)</code></pre><p>Passing <code>start_day</code> will make <a href="#Stripeline.genpointings"><code>genpointings</code></a> use a much slower algorithm to compute the pointings; you should use this syntax only if your simulation really needs the increased precision. Typical examples where you really want to do this are the following:</p><ol><li>You want to estimate when and how long an object in the sky (e.g.,  the <a href="https://en.wikipedia.org/wiki/Crab_Nebula">Crab Nebula</a>,  <a href="https://en.wikipedia.org/wiki/Jupiter">Jupiter</a>) will be visible  by Strip;</li><li>A variation of the previous point is to compute when bright  objects (Sun, Moon, etc.) might be dangerously close to the  boresight direction of the telescope, in order to decide when  the telescope will need to be shut down to prevent overheating or  saturations in the detectors.</li><li>You want to produce a sky map to be compared with those of other  experiments running at the same time as Strip;</li><li>You want to assess how much effects like precession, nutation, and  aberration affect the measurements.</li></ol><h2 id="Reference-documentation-1"><a class="docs-heading-anchor" href="#Reference-documentation-1">Reference documentation</a><a class="docs-heading-anchor-permalink" href="#Reference-documentation-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Stripeline.TENERIFE_LATITUDE_DEG" href="#Stripeline.TENERIFE_LATITUDE_DEG"><code>Stripeline.TENERIFE_LATITUDE_DEG</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Latitude of the LSPE/Strip site in Tenerife, in degrees</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lspestrip/Stripeline.jl/blob/a1630a25aa4a5a12fe9d1f849979cc5cde1c0a12/src/scanning.jl#L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stripeline.TENERIFE_LONGITUDE_DEG" href="#Stripeline.TENERIFE_LONGITUDE_DEG"><code>Stripeline.TENERIFE_LONGITUDE_DEG</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Longitude of the LSPE/Strip site in Tenerife, in degrees</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lspestrip/Stripeline.jl/blob/a1630a25aa4a5a12fe9d1f849979cc5cde1c0a12/src/scanning.jl#L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stripeline.TENERIFE_HEIGHT_M" href="#Stripeline.TENERIFE_HEIGHT_M"><code>Stripeline.TENERIFE_HEIGHT_M</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Height of the LSPE/Strip site in Tenerife, in meters</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lspestrip/Stripeline.jl/blob/a1630a25aa4a5a12fe9d1f849979cc5cde1c0a12/src/scanning.jl#L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stripeline.telescopetoground" href="#Stripeline.telescopetoground"><code>Stripeline.telescopetoground</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">telescopetoground(wheelanglesfn, time_s)</code></pre><p>Return a quaternion of type <code>Quaternion{Float64}</code> representing the coordinate transform from the focal plane to the ground of the telescope. The parameter <code>wheelanglesfn</code> must be a function which takes as input a time, <code>time_s</code>, in seconds, and it must return a 3-tuple containing the angles of the following motors, measured in <strong>radians</strong>:</p><ol><li><p>The boresight motor (rotation around the <span>$z$</span> axis, counterclockwise)</p></li><li><p>The altitude motor (rotation around the <span>$y$</span> axis, counterclockwise)</p></li><li><p>The ground motor (rotation around the <span>$z$</span> axis, <strong>clockwise</strong>: N→E→S→W)</p></li></ol><p><strong>Example</strong></p><pre><code class="language-julia">telescopetoground(3600.0) do
    # Boresight motor keeps a constant angle equal to 0°
    # Altitude motor remains at 20° from the Zenith
    # Ground motor spins at 1 RPM
    (0.0, deg2rad(20.0), timetorotang(time_s, 1))
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lspestrip/Stripeline.jl/blob/a1630a25aa4a5a12fe9d1f849979cc5cde1c0a12/src/scanning.jl#L112-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stripeline.groundtoearth" href="#Stripeline.groundtoearth"><code>Stripeline.groundtoearth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">groundtoearth(groundq, time_s, latitude_deg; day_duration_s=86400.0)</code></pre><p>Return a quaternion of type <code>Quaternion{Float64}</code> representing the coordinate transformation from the ground of the telescope to the Equatorial coordinate system. The parameter <code>groundq</code> must be a quaternion describing the coordinate transformation from the focal plane of the telescope to the ground. The parameter <code>time_s</code> must be a time in seconds, and <code>latitude_deg</code> is the latitude (in degrees, N is positive) of the location where the observation is made.</p><p>The keyword <code>day_duration_s</code> specifies the length of a sidereal day in seconds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lspestrip/Stripeline.jl/blob/a1630a25aa4a5a12fe9d1f849979cc5cde1c0a12/src/scanning.jl#L156-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stripeline.genpointings" href="#Stripeline.genpointings"><code>Stripeline.genpointings</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genpointings!(wheelanglesfn, beam_dir, timerange_s, dirs, psi;
              polaxis = Float64[1.0, 0.0, 0.0],
              latitude_deg = TENERIFE_LATITUDE_DEG,
              ground = false)
genpointings(wheelanglesfn, beam_dir, timerange_s;
             polaxis = Float64[1.0, 0.0, 0.0],
             latitude_deg = TENERIFE_LATITUDE_DEG,
             ground = false)
genpointings!(wheelanglesfn, beam_dir, timerange_s, t_start, dirs, psi;
              polaxis = Float64[1.0, 0.0, 0.0],
              latitude_deg = TENERIFE_LATITUDE_DEG,
              longitude_deg = TENERIFE_LONGITUDE_DEG,
              height_m = TENERIFE_HEIGHT_M,
              precession = true,
              nutation = true,
              aberration = true,
              refraction = true)
genpointings(wheelanglesfn, beam_dir, timerange_s, t_start;
             polaxis=Float64[1.0, 0.0, 0.0],
             latitude_deg=TENERIFE_LATITUDE_DEG,
             longitude_deg=TENERIFE_LONGITUDE_DEG,
             height_m=TENERIFE_HEIGHT_M,
             precession = true,
             nutation = true,
             aberration = true,
             refraction = true)</code></pre><p>Generate a set of pointing directions for a STRIP detector. Each function is provided in two flavours: the ones ending with <code>!</code> save the results in the last two parameters <code>dirs</code> and <code>psi</code>, while the others automatically allocate memory and return their results as a pair <code>(dirs, psi)</code>.</p><p>The parameter <code>wheelanglesfn</code> must be a function which takes as input a time in seconds and returns a 3-tuple containing the angles (in radians) of the three motors:</p><ol><li><p>The boresight motor (rotation around the <span>$z$</span> axis, counterclockwise)</p></li><li><p>The altitude motor (rotation around the <span>$y$</span> axis, counterclockwise)</p></li><li><p>The ground motor (rotation around the <span>$z$</span> axis, <strong>clockwise</strong>: N→E→S→W)</p></li></ol><p>The meaning of the parameters/keywords is the following:</p><ul><li><p><code>beam_dir</code> specifies the pointing direction of the mean (the boresight is [0, 0, 1]). It must be normalized.</p></li><li><p><code>timerange_s</code> is an enumerable type that specifies at which times (in seconds) pointings must be computed.</p></li><li><p><code>t_start</code> is a DateTime object or a Julian date, which specifies the UTC date and time when the observation starts</p></li><li><p><code>latitude_deg</code> is the latitude of the location where the observation is made (in degrees, North is positive). The default value is <a href="#Stripeline.TENERIFE_LATITUDE_DEG"><code>TENERIFE_LATITUDE_DEG</code></a>.</p></li><li><p><code>longitude_deg</code> is the longitude of the location where the observation is made. The default value is <a href="#Stripeline.TENERIFE_LONGITUDE_DEG"><code>TENERIFE_LONGITUDE_DEG</code></a>.</p></li><li><p><code>height_m</code> is the elevation of the location where the observation is made (in meters). The default value is <a href="#Stripeline.TENERIFE_HEIGHT_M"><code>TENERIFE_HEIGHT_M</code></a>.</p></li><li><p>If <code>ground</code> is <code>true</code>, the function will return a 4-tuple containing the colatitude and longitude measured in Equatorial coordinates (columns 1 and 2) and in ground coordinates (columns 3 and 4). If <code>ground</code> is <code>false</code>, only the Equatorial coordinates are computed.</p></li><li><p><code>polaxis</code> is the polarization axis; it must be normalized.</p></li><li><p><code>precession</code>: if <code>true</code> (the default), the Earth&#39;s precession is taken into account.</p></li><li><p><code>nutation</code>: if <code>true</code> (the default), the Earth&#39;s nutation is taken into account.</p></li><li><p><code>aberration</code>: if <code>true</code> (the default), stellar aberration is taken into account.</p></li><li><p><code>refraction</code>: if <code>true</code>, refraction corrections are taken into account. As these corrections are only valid for optical wavelengths, the default is <code>false</code>.</p></li></ul><p><strong>Return values</strong></p><p>If <code>t_start</code> is not provided, the function <code>genpointings</code> returns a 2-tuple containing the sky directions (a N×2 array containing declination and right ascension, in Equatorial coordinates) and the polarization angle for each time step. The function <code>genpointings!</code> sets the values in the last two parameters <code>dirs</code> and <code>psi</code>.</p><p>If <code>t_start</code> is provided, the function <code>genpointings</code> returns a 2-tuple (4-tuple) containing the directions (a N×2 or Nx4 array containing the colatitude and the longitude) and the polarization angles at each time step; <code>genpointings!</code> works as above.</p><p><strong>Examples</strong></p><p>Here is an example using the form without <code>t_start</code>:</p><pre><code class="language-julia">dir, psi = genpointings([0, 0, 1], 0:0.1:1) do time_s
    # Boresight motor keeps a constant angle equal to 0°
    # Altitude motor remains at 20° from the Zenith
    # Ground motor spins at 1 RPM
    (0.0, deg2rad(20.0), timetorotang(time_s, 1))
end</code></pre><p>And here is an example using <code>t_start</code>; unlike the previous example, we use a lambda function instead of the <code>do...end</code> notation.</p><pre><code class="language-julia">import Dates

dirs, psi = genpointings(time_s -&gt; (0, deg2rad(20),
                                    timetorotang(time_s, 1)),
                         [0, 0, 1],
                         0:0.1:1,
                         Dates.DateTime(2022, 01, 01, 0, 0, 0),
                         latitude_deg=10.0,
                         longitude_deg=20.0,
                         height_m = 1000) do time_s</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lspestrip/Stripeline.jl/blob/a1630a25aa4a5a12fe9d1f849979cc5cde1c0a12/src/scanning.jl#L456-L587">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stripeline.timetorotang" href="#Stripeline.timetorotang"><code>Stripeline.timetorotang</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">timetorotang(time, rpm)</code></pre><p>Convert a time into a rotation angle, given the number of rotations per minute. The time should be expressed in seconds. The return value is in radians. <code>time</code> can either be a scalar or a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lspestrip/Stripeline.jl/blob/a1630a25aa4a5a12fe9d1f849979cc5cde1c0a12/src/scanning.jl#L96-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stripeline.northdir" href="#Stripeline.northdir"><code>Stripeline.northdir</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">northdir(θ, ϕ)
eastdir(θ, ϕ)</code></pre><p>Compute the North/East versor for a vector. The North for a vector v is along the direction -dv/dθ, as θ is the colatitude and moves along the meridian, and the East is along dv/dϕ.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; northdir(π/2, 0) ≈ [0, 0, 1]
true
julia&gt; eastdir(π/2, 0) ≈ [0, 1, 0]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lspestrip/Stripeline.jl/blob/a1630a25aa4a5a12fe9d1f849979cc5cde1c0a12/src/scanning.jl#L241-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stripeline.eastdir" href="#Stripeline.eastdir"><code>Stripeline.eastdir</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">northdir(θ, ϕ)
eastdir(θ, ϕ)</code></pre><p>Compute the North/East versor for a vector. The North for a vector v is along the direction -dv/dθ, as θ is the colatitude and moves along the meridian, and the East is along dv/dϕ.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; northdir(π/2, 0) ≈ [0, 0, 1]
true
julia&gt; eastdir(π/2, 0) ≈ [0, 1, 0]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lspestrip/Stripeline.jl/blob/a1630a25aa4a5a12fe9d1f849979cc5cde1c0a12/src/scanning.jl#L241-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stripeline.polarizationangle" href="#Stripeline.polarizationangle"><code>Stripeline.polarizationangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">polarizationangle(northdir, eastdir, poldir)</code></pre><p>Calculate the polarization angle projected in the sky in IAU conventions. The parameters <code>northdir</code> and <code>eastdir</code> must be versors that point towards the North and East, respectively; <code>poldir</code> must be a versor that identify the polarization direction projected in the sky. The return value is in radians, and it is zero if the polarization angles points toward East, π/2 if it points toward North, etc.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; polarizationangle([0, 0, 1], [0, 1, 0], [0, 1, 0])
0.0
julia&gt; polarizationangle([0, 0, 1], [0, 1, 0], [0, 0, 1]) |&gt; rad2deg
90.0
julia&gt; polarizationangle([0, 0, 1], [0, 1, 0], [0, 0, -1]) |&gt; rad2deg
-90.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lspestrip/Stripeline.jl/blob/a1630a25aa4a5a12fe9d1f849979cc5cde1c0a12/src/scanning.jl#L210-L230">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../instrumentdb/">« Instrument database</a><a class="docs-footer-nextpage" href="../acquisition/">Data acquisition »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 17 April 2020 15:33">Friday 17 April 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
