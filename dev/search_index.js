var documenterSearchIndex = {"docs":
[{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"DocTestSetup = quote\n    using Stripeline\nend","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we present the basic facilities provided by the Stripeline framework.","category":"page"},{"location":"tutorial/#How-the-Strip-telescope-operates","page":"Tutorial","title":"How the Strip telescope operates","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Stripeline provides the tools necessary to simulate the behavior of the Strip instrument as if it were operated at the site in Tenerife (Spain). The instrument is an array of microwave detectors observing the sky in two frequency bands: 43 GHz (Q-band) and 90 GHz (W-band). The telescope does not stand still, but it performs a continuous rotation around its azimuthal axis, as it is shown in the following video:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"<iframe \n    width=\"560\" \n        height=\"315\" \n    src=\"https://www.youtube.com/embed/01P_5aCmST0\" \n    frameborder=\"0\" \n    allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" \n    allowfullscreen>\n</iframe>","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To simulate the observation of the sky, Stripeline computes the projected direction of the main axis of the telescope (the red beam in the video above) after it has been tilted (first part of the video) and rotated far from the vertical axis (zenith), in the last part of the video. Stripeline considers also the rotation of the Earth, which causes the celestial sphere to rotate as time passes.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To compute the position of the telescope axis in the sky, we can use the genpointings function. This function takes the time of observation and produces a set of «pointings», i.e., a set of angles that specify the direction and orientation of the telescope axis in the sky. If you watch the video above once again, you will realize that the direction in the sky depends on several quantities:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"How much the telescope is tilted with respect to the vertical axis  (zenith)\nHow much the telescope has rotated with respect to the ground  (azimuth)\nWhat is the position of the Earth.","category":"page"},{"location":"tutorial/#Pointing-generation","page":"Tutorial","title":"Pointing generation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Nominally, the azimuth motor makes the Strip telescope rotate once every minute. Stripeline provides an handy function, [timetorotang] that computes the angle (in radians) of the azimuth axis, given the time in seconds and the rotation speed (in Rotations Per Minute, i.e., RPM):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Stripeline\n\n# What's the azimuth angle after 5 seconds,\n# if the telescope spins once every minute?\ntimetorotang(5.0, 1) |> rad2deg","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"An important feature of Stripeline is that all angles are expressed in radians, unless otherwise noted. This permits to use these angles in trigonometric functions like sin and cos without the need to convert them. In the example above, we used Julia's standard function rad2deg to convert the value to degrees.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The detectors used by Strip operate continuously, taking 100 measurements each second, so if we run a simulation lasting one minute (from 0 to 60 s), we will collect 6,001 samples:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"time_samples = 0.0:0.01:60.0\ndirs, psi = genpointings([0, 0, 1], time_samples) do time_s\n    return (0.0, deg2rad(20.0), timetorotang(time_s, 1))\nend\n\n(size(dirs), size(psi))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The variable time_samples is a range, containing the values 0, 0.01, 0.02, 0.03, …, 59.99, 60.0 in compact form. The call to genpointings uses the do syntax to specify an anonymous function that takes the time time_s as input and returns a tuple of three values: the boresight angle (0.0), the angular distance from the zenith (20°), and the azimuthal angle of the ground motor. (Note that in Julia you can avoid the return in the last statement of a function; we have explicitly written it in this example for the sake of clarity.)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can plot the colatitude, the longitude, and the orientation as a function of time using the plot function from the Plots.jl package:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\nplot(\n    plot(time_samples, rad2deg.(dirs[:, 1]), label = \"Colatitude\"),\n    plot(time_samples, rad2deg.(dirs[:, 2]), label = \"Longitude\"),\n    plot(time_samples, rad2deg.(psi), label = \"Orientation\"),\n    layout = (3, 1), size = (600, 800),\n)\nsavefig(\"coordinates.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If you inspect these plots, you will see the behavior of the video at the top of this page:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The colatitude fluctuates around the mean value 28°, which is  Tenerife's latitude. The amplitude of the fluctuation is 20°,  which is the angle between the Zenith and the red beam pointing  towards the sky.\nThe longitude oscillates around the value 0°, and its amplitude is  20° again;","category":"page"},{"location":"simulation_tutorial/#Simulation-tutorial","page":"Full-scale simulation tutorial","title":"Simulation tutorial","text":"","category":"section"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"The aim of this tutorial is to describe how you can use the functions provided by Stripeline to perform a complete simulation of the LSPE/STRIP experiment.","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"Caution: this page contains some syntax that has been superseded. Refer to the file examples/e2e_simulation.jl for an updated version of this example that runs under Julia 1.6.","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"So far, the simulation includes:","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"simulation of the telescope scanning the sky\nsimulation of noise (white and 1/f)\nproduction of a tod \nproduction of a map by using the destriping technique","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"Two examples will be presented: ","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"a simple case, in which we produce and analyze a very small TOD (1 day observation).  You should refer to this case if you want to use a Jupyter Notebook to perform preliminary studies (since you cannot use MPI in a notebook).\na more general and realistic case, suitable also for the production of large TODs.  In this case it will be necessary to use MPI functions.","category":"page"},{"location":"simulation_tutorial/#.-Simple-Case:-small-TOD","page":"Full-scale simulation tutorial","title":"1. Simple Case: small TOD","text":"","category":"section"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"First of all, you should import the following packages:","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"import Healpix\nimport Random\nimport CorrNoise\nimport Stripeline\nconst Sl = Stripeline\nusing FITSIO","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"In this simple case we can avoid using MPI, but we need the following line:","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"comm = missing\n","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"This is because some of the functions we will use (e.g., the destripe function) require the MPI communicator as input parameter.","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"Then, you can start by setting the simulation parameters:","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"the number of days of observation\nthe number of polarimeters to simulate\nthe sampling frequency (Hz)\nthe length of 1/f baselines (s) as input for the destriper\nthe NSIDE you prefer for your output map\nthe temperature of the sky signal (K)\nthe temperature of the atmosphere (K)\nthe temperature of the telescope (K)\nthe noise temperature of the polarimeters (K)\nthe knee frequency of the polarimeters (Hz)\nthe bandwidth of the polarimeters (Hz)","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"N.B. In the current version of the simulation we consider all polarimeters identical in properties.","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"#Simulation parameters\n\ndays_of_observation = 1\nnum_of_polarimeters = 1\nbaseline_length_s = 10  \nfsamp_hz = 40\nNSIDE = 256\n\ntcmb_k = 3\ntatm_k = 15\nttel_k = 3\ntnoise_k = 35\nfknee_hz = 0.01\nβ_hz = 7e9\n","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"At this point, you can compute some parameters we will need later: the total observation time (in s), the integration time, the total system temperature and the receiver sensitivity.","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"total_time = days_of_observation * 24 * 3600\ntsys_k = tnoise_k + tatm_k + ttel_k + tcmb_k\nτ_s = 1 / fsamp_hz\nσ_k = (tsys_k / sqrt(β_hz * τ_s))","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"Open now the input map, that is to say the sky you want to scan with your instrument.  You can find two example input maps (with two different resolutions) here.","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"Those maps have been produced with PySM and are specific for the STRIP case: they are 43 GHz maps of polarized emission only (cmb, synchrotron and dust).  If you want to produce your own input map, you can use this python script.","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"inputmap = Healpix.readMapFromFITS(raw\"PySM_inputmap_nside256.fits\", 2 , Float64)\ninputmap_resol = inputmap.resolution\n\nresol = Healpix.Resolution(NSIDE) #desired resolution for output map\nnum_of_pixels = resol.numOfPixels","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"You can now scan the input map according to your scanning strategy, thus producing the pure signal \"sky TOD\".  In this case, we use the nominal scanning strategy for STRIP (Tenerife latitude, 20° of elevation angle, 1 RPM)","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"#Generate sky tod\n\ntimes = 0:τ_s: (total_time-τ_s)\n(dirs, ψ) = Sl.genpointings([0., 0., 1.], times; latitude_deg=28.29) do time_s\n    return (0.0, deg2rad(20.0), Sl.timetorotang(time_s, 1.))\nend\n\npix_idx_inputmap = Healpix.ang2pixRing.(Ref(inputmap_resol), dirs[:, 1], dirs[:, 2])\npix_idx = Healpix.ang2pixRing.(Ref(resol), dirs[:, 1], dirs[:, 2])\n\nsky_tod = inputmap.pixels[pix_idx_inputmap]","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"Now you should add noise to your sky tod. We simulate both white noise and 1/f noise, in accordance with the noise properties of the polarimeters specified at the beginning of the script.  To do that, we use the functions of the module CorrNoise.jl.","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"#Generate noise\n\nseed = rand(1:1000)\nrng = CorrNoise.OofRNG(CorrNoise.GaussRNG(Random.MersenneTwister(seed)), -1, 1.15e-5, fknee_hz, fsamp_hz);\nnoise_tod = [CorrNoise.randoof(rng) * σ_k for i in 1:(fsamp_hz * total_time)]\n","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"Finally, you can get the final, realistic TOD just by doing:","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"tod = sky_tod + noise_tod","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"Once you have completed the simulation, you can do data analysis! For instance, you can call the destriper and clean the map from 1/f noise.","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"(N.B. the destriper needs in input an array containing the lengths of all 1/f baselines.  For the sake of semplicity, we consider baselines of equal length).","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"#Run the destriper\n\nbaseline_len = repeat([baseline_length_s*fsamp_hz],Int64(total_time/baseline_length_s))\n\n(destr_map, a) = Sl.destripe(pix_idx, tod, num_of_pixels, baseline_len, comm)","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"The output of the destriper are:","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"destr_map : the destriped map, cleaned from 1/f noise.\na : the baselines array.","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"If you wish, you can finally convert the destriped map (Array{Float64,1}) into a HEALPix map and save it in a FITS file:","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"#save file \n\nmapfile = Healpix.Map{Float64,Healpix.RingOrder}(NSIDE)\nmapfile.pixels = destr_map\n\nHealpix.saveToFITS(mapfile, \"destriped_map.fits\", typechar = \"D\")","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"To run this script you can use the following command:","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"julia simplecase.jl","category":"page"},{"location":"simulation_tutorial/#.-General-Case","page":"Full-scale simulation tutorial","title":"2. General Case","text":"","category":"section"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"In realistic cases, TODs are really huge (millions or billions of samples!).  This means a lot of memory allocation. In the case of Strip, 49 polarimeters observing the sky for 2 years with a sampling frequency of 100 Hz produce 300 billions of samples, which means about 2 Terabytes of memory allocation!","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"It is much more than a single computer can support. It is thus compulsory to split the TOD simulation and analysis between different computing units, by using MPI.","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"Let's go through all the points of the simulation and see how things change:","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"You have to add the MPI package to your dependencies. ","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"import MPI\n\nimport Healpix\nimport Random\nimport CorrNoise\nimport Stripeline\nconst Sl = Stripeline\nusing FITSIO\n","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"Nothing changes with respect to the case above.","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"#Simulation parameters\n\ndays_of_observation = 1\nnum_of_polarimeters = 1\nbaseline_length_s = 10  \nfsamp_hz = 40\nNSIDE = 256\n\ntcmb_k = 3\ntatm_k = 15\nttel_k = 3\ntnoise_k = 35\nfknee_hz = 0.01\nβ_hz = 7e9\n","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"You should add the computation of the total number of samples per polarimeter and total number of baselines for polarimeter, which we will need later.","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"total_time = days_of_observation * 24 * 3600\ntsys_k = tnoise_k + tatm_k + ttel_k + tcmb_k\nτ_s = 1 / fsamp_hz\nσ_k = (tsys_k / sqrt(β_hz * τ_s))\n\nsamples_per_pol = total_time*fsamp_hz \nbaselines_per_pol = Int64(total_time/baseline_length_s)","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"Nothing changes.","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"inputmap = Healpix.readMapFromFITS(raw\"PySM_inputmap_nside256.fits\", 2 , Float64)\ninputmap_resol = inputmap.resolution\n\nresol = Healpix.Resolution(NSIDE) #desired resolution for output map\nnum_of_pixels = resol.numOfPixels","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"Before scanning the input map we have to conveniently split the TOD production among the available computing units.  First of all, we need to initialize MPI:","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"MPI.Init()\n\ncomm = MPI.COMM_WORLD\nrank = MPI.Comm_rank(comm)\ncommsize = MPI.Comm_size(comm) \n","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"Then, we can proceed with the TOD splitting.","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"The splitting is done in a way that each rank gets a whole number of 1/f baselines to simulate and that the TOD chunks are of as similar length as possible.","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"We also need to tell to each unit which detector to simulate and from which to which time.  By using the get_chunk_properties function, we can obtain these information for the current rank.","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"#Split tod production \n\nbaselines_per_process = Sl.split_into_n(num_of_polarimeters*baselines_per_pol, commsize)\nchunks = Sl.split_tod_mpi(total_time, baseline_length_s, baselines_per_process, commsize)\nthis_rank_chunk = chunks[rank+1]\n\n(detector_number, first_time, last_time, num_of_baselines, num_of_samples) = Sl.get_chunk_properties(chunks, baseline_length_s, fsamp_hz, rank)\n","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"Concerning the production of the sky TOD, of course each computing unit will produce its own partial TOD using the information obtained before.  A loop on detectors has been added, since in the general case the simulation involves more than one detector, and moreover, each rank may have to simulate partial tods for different detectors.","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"#Generate sky tod\n\npix_idx = Int64[]\npix_idx_inputmap = Int64[]\nsky_tod = Float64[]\n\n\nfor i in 1:length(this_rank_chunk)   #loop on detectors\n\n    #generate pointings according to STRIP scanning strategy\n\n    times = first_time[i]:τ_s:last_time[i]\n\n \n    (dirs, ψ) = Sl.genpointings([0., 0., 1.], times; latitude_deg=28.29) do time_s\n        return (0.0, deg2rad(20.0), Sl.timetorotang(time_s, 1.))\n    end\n\n    partial_pix_idx_inputmap = Healpix.ang2pixRing.(Ref(inputmap_resol), dirs[:, 1], dirs[:, 2])\n    partial_pix_idx = Healpix.ang2pixRing.(Ref(resol), dirs[:, 1], dirs[:, 2])\n\n    #build the sky tod\n    partial_sky_tod = inputmap.pixels[partial_pix_idx_inputmap]\n    global sky_tod = append!(sky_tod, partial_sky_tod)\n    global pix_idx = append!(pix_idx, partial_pix_idx)\nend\n","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"To generate noise, you e can use the generate_noise_mpi function, which directly returns the partial noise TOD for the current rank.","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"#Generate noise\n\nnoise_tod = Sl.generate_noise_mpi(chunks, baselines_per_process, baseline_length_s, fsamp_hz, σ_k, fknee_hz, rank, comm)","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"nothing changes.","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"tod = sky_tod + noise_tod","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"nothing changes apart from baseline_len definition (since now different units can have a different amount of baselines to compute).","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"The destripe function already takes into account the presence of multiple computing units: each partial TOD is loaded separately and partial maps are build, but then MPI functions are called to make different ranks \"talk together\" in order to obtain in output a single global destriped map.","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"#Run the destriper\n\nbaseline_len = repeat([baseline_length_s*fsamp_hz], baselines_per_process[rank+1])\n(destr_map, a) = Sl.destripe(pix_idx, tod, num_of_pixels, baseline_len, comm)","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"If you want to save the destriped map in a .fits file, you should make just one rank do that.","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"#save file \n\nif(rank==0)\n    mapfile = Healpix.Map{Float64,Healpix.RingOrder}(NSIDE)\n    mapfile.pixels = destr_map\n    Healpix.saveToFITS(mapfile, \"destriped_map.fits\", typechar = \"D\")\nend","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"Finally, end your script by terminating the calling to MPI environment.","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"MPI.Finalize()","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"To run this script, you can use the following code (using 3 MPI processes):","category":"page"},{"location":"simulation_tutorial/","page":"Full-scale simulation tutorial","title":"Full-scale simulation tutorial","text":"mpirun -n 3 julia generalcase.jl","category":"page"},{"location":"acquisition/","page":"Data acquisition","title":"Data acquisition","text":"DocTestSetup = quote\n    using Stripeline\nend","category":"page"},{"location":"acquisition/#Simulating-data-acquisition","page":"Data acquisition","title":"Simulating data acquisition","text":"","category":"section"},{"location":"acquisition/","page":"Data acquisition","title":"Data acquisition","text":"An essential part of Strip polarimeters is the set of four Analogue-to-Digital Converters (ADC) that measure input voltages as 20-bit digital numbers. This process is called quantization, and it is a non-invertible operation that causes loss of information. Ideal ADCs perform a linear operation (modulo a rounding operation), but real-world components are never perfectly linear.","category":"page"},{"location":"acquisition/","page":"Data acquisition","title":"Data acquisition","text":"Because of the fact that CMB experiments like Strip measure brightness temperatures, Stripeline models ADCs as devices that convert temperatures into ADUs, neglecting the fact that Strip polarimeters convert incoming fluxes into voltages.","category":"page"},{"location":"acquisition/","page":"Data acquisition","title":"Data acquisition","text":"Stripeline offers a few functions to simulate the behaviour of an ADC. The simulation of ADC behaviour is useful to estimate the impact of quantization and non linearities. The following schema show how things work:","category":"page"},{"location":"acquisition/","page":"Data acquisition","title":"Data acquisition","text":"(Image: )","category":"page"},{"location":"acquisition/","page":"Data acquisition","title":"Data acquisition","text":"Function adc_response takes a temperature as input, and it produces the output that would be emitted by an ADC. The function adc_inv_response performs the reverse transformation: it converts a digital number back to a temperature. Function adc_filter combines the two functions: it takes a temperature as input, and it returns the temperature that has been measured by the ADC, including the effect of quantization and non linearities.","category":"page"},{"location":"acquisition/","page":"Data acquisition","title":"Data acquisition","text":"An important difference between adc_response and adc_inv_response is the fact that adc_response considers non linearities, while adc_inv_response does not.","category":"page"},{"location":"acquisition/","page":"Data acquisition","title":"Data acquisition","text":"ADC\noptimized_adc\nadc_response\nadc_inv_response\nadc_filter","category":"page"},{"location":"acquisition/#Stripeline.ADC","page":"Data acquisition","title":"Stripeline.ADC","text":"A structure representing the configuration of an Analogue-to-Digital Converter (ADC). To simplify things, we assume that the ADC is fed with some temperature, instead of a voltage. In this case we can avoid dealing with the calibration from Volt to Kelvin, which is seldom useful in simulations.\n\nThe equation used to model the ADC is the following:\n\nx(V) = round(gain_k_over_adu * (V - offset_k)) + zero_point_adu\n\nand the output is clipped within a user-defined range. The following fields are available:\n\noffset_k\ngain_k_over_adu\nzero_point_adu\nmin_output_adu: output values below this will be clipped\nmax_output_adu: output values above this will be clipped\nnon_linearities_x_adu: see below\nnon_linearities_y_adu: see below\n\nNon linearities must be specified using the two arrays non_linearities_x_adu and non_linearities_y_adu. For each input voltage fed to the ADC, a non linearity is applied to the output according to the following algorithm:\n\nThe function computes the ideal output (i.e., without non linearities);\nIt checks if the value of the ideal output is found in the array non_linearities_x_adu;\nIf the value is found, add the corresponding value in the array non_linearities_y_adu (i.e., the element with the same index as the element in non_linearities_x_adu) to the ideal output;\nIf the value is not found, but it falls within two consecutive values, use a linear interpolation;\nIf the value is smaller than the first element or larger than the last element in non_linearities_x_adu, do not apply any correction to the output.\n\nIt is fundamental that non_linearities_x_adu is sorted in ascending order, and that the order of the in elements non_linearities_y_adu matches the order in non_linearities_x_adu.\n\n\n\n\n\n","category":"type"},{"location":"acquisition/#Stripeline.optimized_adc","page":"Data acquisition","title":"Stripeline.optimized_adc","text":"optimized_adc(; min_input_k = 0.0, max_input_k = 100.0, dynamic_range = 0.35, nbits = 20, non_linearities_x_adu = Float64[], non_linearities_y_adu = Float64[])\n\nReturn an object of type ADC that is optimized to measure temperatures between min_input_k and max_input_k. The ADC is configured to return signed numbers in the range -2^nbits…2^nbits.\n\nThe function accepts the following keywords:\n\nmin_input_k: temperature that should trigger the lowest output within the dynamic range\nmax_input_k: temperature that should trigger the lowest output within the dynamic range\ndynamic_range: pure number in the interval 0…1 that specifies the dynamic range of the output\nnbits: number of bits used by the ADC\nnon_linearities_x_adu: same parameter used in the constructor for ADC\nnon_linearities_y_adu: same parameter used in the constructor for ADC\n\n\n\n\n\n","category":"function"},{"location":"acquisition/#Stripeline.adc_response","page":"Data acquisition","title":"Stripeline.adc_response","text":"adc_response(adc::ADC, input_k; include_non_linearities = true)\n\nSimulate the response of an ADC on some voltage input_k. If include_non_linearities is true, non-linearities specified in adc will be considered; otherwise, the ADC will be assumed to be ideal.\n\nSee also adc_inv_response for the (pseudo)inverse function.\n\n\n\n\n\n","category":"function"},{"location":"acquisition/#Stripeline.adc_inv_response","page":"Data acquisition","title":"Stripeline.adc_inv_response","text":"adc_inv_response(adc::ADC, input_adu)\n\nApply the inverse transformation of an ADC to get some voltage from a digital measurement in ADU.This function assumes that the ADC is ideal, i.e., that it does not have non-linearities.\n\nSee also adc_response.\n\n\n\n\n\n","category":"function"},{"location":"acquisition/#Stripeline.adc_filter","page":"Data acquisition","title":"Stripeline.adc_filter","text":"adc_filter(adc::ADC, input_k; include_non_linearities = true)\n\nSimulate the measurement of the temperature input_k through the ADC adc. The result is still a temperature, after it has been converted into ADUs by the ADC and then converted back to a temperature again. If non-linearities are specified in adc, they will be applied only to the K→ADU transformation.\n\n\n\n\n\n","category":"function"},{"location":"basic/","page":"Basic functions","title":"Basic functions","text":"DocTestSetup = quote\n    using Stripeline\nend","category":"page"},{"location":"basic/#Basic-functions","page":"Basic functions","title":"Basic functions","text":"","category":"section"},{"location":"basic/#Measure-unit-conversion","page":"Basic functions","title":"Measure unit conversion","text":"","category":"section"},{"location":"basic/","page":"Basic functions","title":"Basic functions","text":"It is often useful to convert measurements between thermodynamic temperatures and Rayleigh-Jeans temperatures. The following functions implement this kind of conversion. Note that there are two families of functions:","category":"page"},{"location":"basic/","page":"Basic functions","title":"Basic functions","text":"Functions that convert absolute measurements: t_to_trj, trj_to_t;\nFunctions that convert sensitivities (i.e., small fluctuations around an absolute value): deltat_to_deltatrj, deltatrj_to_deltat","category":"page"},{"location":"basic/","page":"Basic functions","title":"Basic functions","text":"The function sensitivity_tant computes the overall sensitivity of a set of polarimeters, using information from The Strip Instrument Database.","category":"page"},{"location":"basic/","page":"Basic functions","title":"Basic functions","text":"sensitivity_tant\nt_to_trj\ntrj_to_t\ndeltat_to_deltatrj\ndeltatrj_to_deltat","category":"page"},{"location":"basic/#Stripeline.sensitivity_tant","page":"Basic functions","title":"Stripeline.sensitivity_tant","text":"sensitivity_tant(db::InstrumentDB, load_tant; modules = Set([0, 1, 2, 3, 4, 5, 6]))\n\nCalculate the white-noise sensitivity of an array of detectors, measured in K⋅√s, given some antenna temperature for the load. The result takes in account only those horns belonging to the modules listed in the keyword modules (the W-band horns belong to module -1). By default, only the Q-band modules are considered.\n\nThe result assumes the radiometer equation: στ = fracT_sys2β, where T_{sys} is the system temperature, β is the bandwidth, and τ is the acquisition time. The factor 2 comes from the way Strip polarimeters operate. The system temperature is assumed to be the noise temperature of each detector, plus the term load_tant, which should take into account all the other sources of power entering the system (e.g., telescope, atmosphere, etc.). The term load_tant should be expressed as an antenna temperature.\n\n\n\n\n\n","category":"function"},{"location":"basic/#Stripeline.t_to_trj","page":"Basic functions","title":"Stripeline.t_to_trj","text":"t_to_trj(temperature_k, nu_hz)\n\nConvert a thermodynamic temperature (in K) into a Rayleigh-Jeans temperature, given some specified frequency nu_hz (in Hz).\n\nSee also trj_to_t for the inverse transformation.\n\n\n\n\n\n","category":"function"},{"location":"basic/#Stripeline.trj_to_t","page":"Basic functions","title":"Stripeline.trj_to_t","text":"trj_to_t(temperature_k, nu_hz)\n\nConvert a Rayleigh-Jeans temperature (in K) into a thermodynamic temperature, given some specified frequency nu_hz (in Hz).\n\nSee also t_to_trj for the inverse transformation.\n\n\n\n\n\n","category":"function"},{"location":"basic/#Stripeline.deltat_to_deltatrj","page":"Basic functions","title":"Stripeline.deltat_to_deltatrj","text":"deltat_to_deltatrj(temperature_k, deltat_k, nu_hz)\n\nConvert a small temperature fluctuation deltat_k around temperature temperature_k from thermodynamic temperature to Rayleigh-Jeans (RJ) temperature. This function can be used to convert sensitivities expressed as thermodynamic temperatures in RJ sensitivities.\n\nSee also deltatrj_to_deltat for the inverse function.\n\n\n\n\n\n","category":"function"},{"location":"basic/#Stripeline.deltatrj_to_deltat","page":"Basic functions","title":"Stripeline.deltatrj_to_deltat","text":"deltat_to_deltatrj(temperature_k, deltat_k, nu_hz)\n\nConvert a small temperature fluctuation deltat_k around temperature temperature_k from Rayleigh-Jeans (RJ) temperature to thermodynamic temperature. This function can be used to convert sensitivities expressed as RJ temperatures in thermodynamic sensitivities.\n\nSee also deltatrj_to_deltat for the inverse function.\n\n\n\n\n\n","category":"function"},{"location":"instrumentdb/","page":"Instrument database","title":"Instrument database","text":"DocTestSetup = quote\n    using Stripeline\nend","category":"page"},{"location":"instrumentdb/#The-Strip-Instrument-Database","page":"Instrument database","title":"The Strip Instrument Database","text":"","category":"section"},{"location":"instrumentdb/#Introduction","page":"Instrument database","title":"Introduction","text":"","category":"section"},{"location":"instrumentdb/","page":"Instrument database","title":"Instrument database","text":"Every simulator of a scientific experiment needs an «instrument database», i.e., a way to access the specification of the instrument to be simulated. The kind of information stored in this database is the following:","category":"page"},{"location":"instrumentdb/","page":"Instrument database","title":"Instrument database","text":"How many detectors are present in the instrument, and what are   their characteristics in terms of noise and placement on the focal   plane;\nWhat is the response of the optical elements, i.e., the so-called   beam function;\nWhich frequencies can be measured by each detector (the so-called   bandpass);\nEct.","category":"page"},{"location":"instrumentdb/","page":"Instrument database","title":"Instrument database","text":"Stripeline implements an instrument database using YAML files and two data structures, Detector and Horn, plus some functions to easily access the information in them.","category":"page"},{"location":"instrumentdb/","page":"Instrument database","title":"Instrument database","text":"The following example initializes an object of type InstrumentDB with the values referred to the standard STRIP instrument:","category":"page"},{"location":"instrumentdb/","page":"Instrument database","title":"Instrument database","text":"using Stripeline; # hide\ndb = InstrumentDB()","category":"page"},{"location":"instrumentdb/","page":"Instrument database","title":"Instrument database","text":"This command loads the YAML files provided in the Stripeline repository and initializes the db object. As db is a struct, its field can be accessed with the usual dot notation. The two fields in db are focalplane and detectors. They are both dictionaries, associating horn names to Horn objects and detectors IDs to Detector objects, respectively:","category":"page"},{"location":"instrumentdb/","page":"Instrument database","title":"Instrument database","text":"db.focalplane[\"I0\"]\ndb.detectors[2]","category":"page"},{"location":"instrumentdb/","page":"Instrument database","title":"Instrument database","text":"A number of high-level functions ease the access of the fields in a InstrumentDB object:","category":"page"},{"location":"instrumentdb/","page":"Instrument database","title":"Instrument database","text":"detector returns a Detector structure, containing the details of a polarimeter;\nbandpass returns a BandshapeInfo structure, containing the shape of the bandpass of a detector;\nspectrum returns a SpectrumInfo\nfknee_hz returns the knee frequency of the 1/f noise for the I, Q, and U signals, adapted to the brightness temperature of the load being observed by the detector;\ntnoise returns the noise temperature for the I, Q, and U components.","category":"page"},{"location":"instrumentdb/","page":"Instrument database","title":"Instrument database","text":"The structure Detector uses three structures to organize its data in a hierarchical way:","category":"page"},{"location":"instrumentdb/","page":"Instrument database","title":"Instrument database","text":"BandshapeInfo\nSpectrumInfo\nNoiseTemperatureInfo","category":"page"},{"location":"instrumentdb/","page":"Instrument database","title":"Instrument database","text":"All these structures know how to show themselves on the REPL:","category":"page"},{"location":"instrumentdb/","page":"Instrument database","title":"Instrument database","text":"db.detectors[2].bandshape\ndb.detectors[2].spectrum\ndb.detectors[2].tnoise","category":"page"},{"location":"instrumentdb/","page":"Instrument database","title":"Instrument database","text":"Some of them have the ability to be plotted using Plots.jl:","category":"page"},{"location":"instrumentdb/","page":"Instrument database","title":"Instrument database","text":"using Plots\nplot(db.detectors[2].bandshape)\nsavefig(\"instrumentdb-bandshape.svg\"); nothing # hide","category":"page"},{"location":"instrumentdb/","page":"Instrument database","title":"Instrument database","text":"(Image: )","category":"page"},{"location":"instrumentdb/","page":"Instrument database","title":"Instrument database","text":"For more information about the fields in the structures listed above, as well as their meaning, keep reading.","category":"page"},{"location":"instrumentdb/#Structures","page":"Instrument database","title":"Structures","text":"","category":"section"},{"location":"instrumentdb/","page":"Instrument database","title":"Instrument database","text":"InstrumentDB\nHorn\nDetector\nBandshapeInfo\nbandshape\nSpectrumInfo\nNoiseTemperatureInfo","category":"page"},{"location":"instrumentdb/#Stripeline.InstrumentDB","page":"Instrument database","title":"Stripeline.InstrumentDB","text":"STRIP instrument database\n\nThe \"database\" contains information about feed horns and polarimeters:\n\nThe field focalplane is a dictionary (mapping) associating the string identifying a horn (e.g., I0) with a Horn structure;\nThe field detectors is a dictionary associating the ID of the polarimeter (e.g., 2 stands for STRIP02) with a Detector structure.\n\nYou should usually create an object of this kind using the default constructor, which parses a set of YAML files containing the real parameters of the instrument.\n\nExamples\n\njulia> db = InstrumentDB();\n\njulia> print(\"Number of horns in the database: $(length(keys(db.focalplane)))\")\nNumber of horns in the database: 55\n\njulia> print(\"Number of polarimeters in the database: $(length(keys(db.detectors)))\")\nNumber of polarimeters in the database: 66\n\nVisualization\n\nYou can produce a table describing the contents of the instrument database using show and passing text/markdown as MIME type:\n\ndb = InstrumentDB()\nshow(stdout, MIME(\"text/markdown\"), db)\n\nThe table can be converted to other formats (HTML, LaTeX, Microsoft Word, …) using commonly-available tools, e.g., Pandoc.\n\n\n\n\n\n","category":"type"},{"location":"instrumentdb/#Stripeline.Horn","page":"Instrument database","title":"Stripeline.Horn","text":"Information about a STRIP horn\n\nThis structure holds a number of parameters relative to each feed horn in the STRIP focal plane.\n\nYou should initialize Horn objects via the InstrumentDB constructor, which loads their definition from a STRIP instrument database in YAML format.\n\nField Type Meaning\nname String Name of the horn, e.g., I0\nid Int Unique number of the horn, starting from 1\npolid Int Unique ID of the polarimeter associated with the horn\npolarizerid Int Unique ID of the polarizer+OMT associated with the horn\nmoduleid Int Number of the horn within the module, from 0 to 6\ncolor String Name of the color associated with the module\norientation Array{Float64} 3D vector containing the orientation of the horn in the sky\nfwhm_x_deg Float64 FWHM of the beam along the X axis, in degrees\nfwhm_y_deg Float64 FWHM of the beam along the Y axis, in degrees\nmain_spillover Float64 Main reflector spillover\nsub_spillover Float64 Sub-reflector spillover\nxpd_db Float64 Cross-polarization, in dB\ndirectivity_dbi Float64 Directivity, in dBi\nellipticity Float64 Ellipticity\n\n\n\n\n\n","category":"type"},{"location":"instrumentdb/#Stripeline.Detector","page":"Instrument database","title":"Stripeline.Detector","text":"Information about a STRIP detector\n\nThis structure holds information about a STRIP polarimeter.\n\nYou should initialize Detector objects via the InstrumentDB constructor, which loads their definition from a local STRIP instrument database.\n\nField Type Meaning\nid Int Integer ID of the polarimeter, e.g., 2 for STRIP02\nname String Full name of the polarimeter, e.g., STRIP02\nband String Band: it can either be Q or W\nbandshape BandshapeInfo Information about the bandpass response\nspectrum SpectrumInfo Information about the noise spectrum (white noise and 1/f noise)\ntnoise NoiseTemperatureInfo Information about the noise temperature\n\n\n\n\n\n","category":"type"},{"location":"instrumentdb/#Stripeline.BandshapeInfo","page":"Instrument database","title":"Stripeline.BandshapeInfo","text":"BandshapeInfo\n\nInformation about the spectral band response of a polarimeter.\n\nField Type Meaning\ncenter_frequency_hz Float64 Estimate for the center frequency, in Hz\ncenter_frequency_err_hz Float64 Estimated error on the center frequency, in Hz\nbandwidth_hz Float64 Estimated bandwidth, in Hz\nbandwidth_err_hz Float64 Estimated error on the bandwidth, in Hz\nlowest_frequency_hz Float64 Lowest frequency of the bandshape in response, in Hz\nhighest_frequency_hz Float64 Highest frequency of the bandshape in response, in Hz\nnum_of_frequencies Int Number of samples in response\nbandshape Array{Float64,1} Profile of the bandshape (pure numbers)\nbandshape_error Array{Float64,1} Estimated error on the profile of the bandshape\ntest_id Array{Int,1} ID of the unit-level test used to characterize the bandshape\nanalysis_id Int ID of the unit-level analysis used to characterize the bandshape\n\nYou can plot a BandshapeInfo object by importing Plots and using plot:\n\ndb = InstrumentDB()\nplot(bandpass(db, \"I0\"), show_error = true)\n\nThe following keywords are recognized in the call to plot:\n\nshow_error (default: true): include an error bar.\nshow_centerfreq (default: false): include a vertical bar showing the position of the center frequency\n\n\n\n\n\n","category":"type"},{"location":"instrumentdb/#Stripeline.bandshape","page":"Instrument database","title":"Stripeline.bandshape","text":"bandshape(bandinfo::BandshapeInfo) -> Tuple{Array{Float64, 1}, Array{Float64, 1}}\nbandshape(db::InstrumentDB, polid::Integer) -> Tuple{Array{Float64, 1}, Array{Float64, 1}}\nbandshape(db::InstrumentDB, horn_name::AbstractString) -> Tuple{Array{Float64, 1}, Array{Float64, 1}}\n\nReturn a pair (ν_hz, B, Berr) containing the shape of the bandpass in bandinfo (first form), or the bandpass taken from the instrument database (second and third form). The two elements of the tuple (ν_hz, B) are two arrays of the same length containing the frequencies (in Hz) and the bandpass response at the same frequency (pure number), and they are suitable to be plotted, like in the following example:\n\ndb = InstrumentDB()\nx, y, err = bandshape(db, \"G2\")\nplot(x, y, ribbon=(err, err))   # Plot the bandpass and the error bar\n\nHowever, it is easier just to use plot on a BandshapeInfo object.\n\n\n\n\n\n","category":"function"},{"location":"instrumentdb/#Stripeline.SpectrumInfo","page":"Instrument database","title":"Stripeline.SpectrumInfo","text":"SpectrumInfo\n\nInformation about the noise spectrum of the output of a polarimeter.\n\nField Type Meaning\nslope_i Float64 The slope (alpha) of the 1/f component of the noise in the I signal\nslope_i_err Float64 Error associated with the value of slope_i\nslope_q Float64 Same as slope_i, but for the Q signal\nslope_q_err Float64 Error associated with the value of slope_q\nslope_u Float64 Same as slope_i, but for the U signal\nslope_u_err Float64 Error associated with the value of slope_u\nfknee_i_hz Float64 Knee frequency of the I signal, in Hz\nfknee_i_err_hz Float64 Error associated with the value of fknee_i_hz\nfknee_q_hz Float64 Knee frequency of the Q signal, in Hz\nfknee_q_err_hz Float64 Error associated with the value of fknee_q_hz\nfknee_u_hz Float64 Knee frequency of the U signal, in Hz\nfknee_u_err_hz Float64 Error associated with the value of fknee_u_hz\nwn_i_k2_hz Float64 White noise level for the I signal, in K^2 Hz\nwn_i_err_k2_hz Float64 Error associated with the value of wn_i_k2_hz\nwn_q_k2_hz Float64 White noise level for the Q signal, in K^2 Hz\nwn_q_err_k2_hz Float64 Error associated with the value of wn_q_k2_hz\nwn_u_k2_hz Float64 White noise level for the U signal, in K^2 Hz\nwn_u_err_k2_hz Float64 Error associated with the value of wn_u_k2_hz\nload_temperature_k Float64 System brightness temperature used during the tests (in K)\ntest_id Int ID of the unit-level test used to characterize the bandshape\nanalysis_id Int ID of the unit-level analysis used to characterize the bandshape\n\nYou can quickly plot the theoretical shape of the noise power spectrum using plot on a SpectrumInfo object.\n\n\n\n\n\n","category":"type"},{"location":"instrumentdb/#Stripeline.NoiseTemperatureInfo","page":"Instrument database","title":"Stripeline.NoiseTemperatureInfo","text":"NoiseTemperatureInfo\n\nInformation about the noise temperature of a polarimeter. This structure is used for the field tnoise of the Detector struct.\n\nField Type Meaning\ntnoise_k Float64 Noise temperature computed from tnoise_values_k, in K\ntnoise_err_k Float64 Error associated with tnoise_k, computed from tnoise_values_k\ntest_ids Array{Int,1} List of unit-level test IDs used to estimate the noise temperature\nanalysis_ids Array{Int,1} List of unit-level analysis report IDs used to estimate the noise temperature\nvalues_k Array{Float64,1} List of noise temperatures estimated from the tests\n\n\n\n\n\n","category":"type"},{"location":"instrumentdb/#High-level-access-functions","page":"Instrument database","title":"High-level access functions","text":"","category":"section"},{"location":"instrumentdb/","page":"Instrument database","title":"Instrument database","text":"detector\nbandpass\nspectrum\nfknee_hz\ntnoise","category":"page"},{"location":"instrumentdb/#Stripeline.detector","page":"Instrument database","title":"Stripeline.detector","text":"detector(db::InstrumentDB, polid::Integer) -> Detector\ndetector(db::InstrumentDB, horn_name::AbstractString) -> Detector\n\nReturn a Detector structure, taken from the instrument database. If the form with polid is used, polid is the progressive number of the polarimeter; e.g., for STRIP02, polid == 2. In the second form, you pass the string identifying the horn on the focal plane, e.g., I0, W3, etc.\n\ndb = InstrumentDB()\npol1 = detector(db, 16)   # Get information about STRIP16\npol2 = detector(db, \"V4\") # Get information about the detector connected to horn V4\n\n\n\n\n\n","category":"function"},{"location":"instrumentdb/#Stripeline.bandpass","page":"Instrument database","title":"Stripeline.bandpass","text":"bandpass(db::InstrumentDB, polid::Integer) -> BandshapeInfo\nbandpass(db::InstrumentDB, horn_name::AbstractString) -> BandshapeInfo\n\nReturn a pair (ν_hz, B) containing the bandpass B for the horn with the specified ID (polid) or associated to some horn (horn_name). To understand how polid and horn_name work, see the documentation for detector.\n\nThe two elements of the tuple (ν_hz, B) are two arrays of the same length containing the frequencies (in Hz) and the bandpass response at the same frequency (pure number).\n\ndb = InstrumentDB()\nx, y = bandpass(db, \"G2\")\nplot(x, y)   # Plot the bandpass\n\nSee also bandshape.\n\n\n\n\n\n","category":"function"},{"location":"instrumentdb/#Stripeline.spectrum","page":"Instrument database","title":"Stripeline.spectrum","text":"spectrum(db::InstrumentDB, polid::Integer) -> SpectrumInfo\nspectrum(db::InstrumentDB, horn_name::AbstractString) -> SpectrumInfo\n\nReturn a SpectrumInfo object, taken from the instrument database. The meaning of the parameters polid and horn_name is explained in the documentation for detector.\n\n\n\n\n\n","category":"function"},{"location":"instrumentdb/#Stripeline.fknee_hz","page":"Instrument database","title":"Stripeline.fknee_hz","text":"fknee_hz(db::InstrumentDB, polid::Integer; tsys_k = missing) -> Tuple{Float64, Float64, Float64}\nfknee_hz(db::InstrumentDB, horn_name::AbstractString; tsys_k = missing) -> Tuple{Float64, Float64, Float64}\n\nReturn the knee frequency for the selected detector, taken from the instrument database. The meaning of the parameters polid and horn_name is explained in the documentation for detector.\n\nIf tsys_k is specified, the system temperature is rescaled to the desired temperature of the load feeding the polarimeter, so that the 1/f component of the noise remains unchanged but the white noise plateau raises/lowers by an appropriate amount. Otherwise, the function returns the raw frequency taken from the instrument database.\n\n\n\n\n\n","category":"function"},{"location":"instrumentdb/#Stripeline.tnoise","page":"Instrument database","title":"Stripeline.tnoise","text":"tnoise(db::InstrumentDB, polid::Integer) -> NoiseTemperatureInfo\ntnoise(db::InstrumentDB, horn_name::AbstractString) -> NoiseTemperatureInfo\n\nReturn a NoiseTemperatureInfo object, taken from the instrument database. The meaning of the parameters polid and horn_name is explained in the documentation for detector.\n\n\n\n\n\n","category":"function"},{"location":"instrumentdb/#Loading-custom-databases","page":"Instrument database","title":"Loading custom databases","text":"","category":"section"},{"location":"instrumentdb/","page":"Instrument database","title":"Instrument database","text":"It is not needed to load the default instrument database, as Stripeline provides a number of additional functions to build mock databases from dictionaries.","category":"page"},{"location":"instrumentdb/","page":"Instrument database","title":"Instrument database","text":"defaultdbfolder\nparsefpdict\nparsedetdict","category":"page"},{"location":"instrumentdb/#Stripeline.defaultdbfolder","page":"Instrument database","title":"Stripeline.defaultdbfolder","text":"defaultdbfolder()\n\nReturn a string containing the (local) full path to the YAML files containing the reference instrument DB.\n\n\n\n\n\n","category":"function"},{"location":"instrumentdb/#Stripeline.parsefpdict","page":"Instrument database","title":"Stripeline.parsefpdict","text":"parsefpdict(fpdict)\n\nReturn a dictionary associating an horn name (e.g., I0) to a Horn object containing information about some horn in the STRIP focal plane. The information are parsed from fpdict, which should be a dictionary loaded from a YAML file. The default YAML file to be used is located in the folder returned by defaultdbfolder and is usually named strip_focal_plane.yaml\n\n\n\n\n\n","category":"function"},{"location":"instrumentdb/#Stripeline.parsedetdict","page":"Instrument database","title":"Stripeline.parsedetdict","text":"parsedetdict(detdict)\n\nReturn a dictionary associating an integer number to a Detector object containing information about the STRIP detector with the corresponding number. The information are parsed from detdict, which should be a dictionary loaded from a YAML file. The default YAML file to be used is located in the folder returned by defaultdbfolder and is usually named strip_detectors.yaml\n\n\n\n\n\n","category":"function"},{"location":"","page":"Introduction","title":"Introduction","text":"DocTestSetup = quote\n    using Stripeline\nend","category":"page"},{"location":"#Stripeline-User's-Manual","page":"Introduction","title":"Stripeline User's Manual","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"An implementation of a simulation/data analysis pipeline for the LSPE/STRIP instrument.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To install Stripeline, start Julia and type the following command:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(PackageSpec(url=\"https://github.com/lspestrip/Stripeline\"))","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To run the test suite, type the following command:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg; Pkg.test(\"Stripeline\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In this manual, we will often assume that Stripeline has been imported using the following commands:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"import Stripeline\nconst Sl = Stripeline","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In this way, we can call functions like genpointings using the syntax Sl.genpointings, instead of the longer Stripeline.genpointings.","category":"page"},{"location":"#Documentation","page":"Introduction","title":"Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The documentation was built using Documenter.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"import Dates: now #hide\nprintln(\"Documentation built $(now()) with Julia $(VERSION).\") # hide","category":"page"},{"location":"#Index","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"mapmaking/","page":"Map making","title":"Map making","text":"DocTestSetup = quote\n    using Stripeline\nend","category":"page"},{"location":"mapmaking/#Map-making-functions","page":"Map making","title":"Map-making functions","text":"","category":"section"},{"location":"mapmaking/","page":"Map making","title":"Map making","text":"Stripeline implements a few functions to produce maps out of time-ordered data.","category":"page"},{"location":"mapmaking/","page":"Map making","title":"Map making","text":"tod2map_mpi\nbaseline2map_mpi\ndestripe","category":"page"},{"location":"mapmaking/#Stripeline.tod2map_mpi","page":"Map making","title":"Stripeline.tod2map_mpi","text":"tod2map(pix_idx, tod, num_of_pixels; comm = nothing) -> binned_map\ntod2map(pix_idx, tod, num_of_pixels, data_properties; comm = nothing) -> binned_map\n\nThis function creates a binned map from the time-ordered data kept in the array tod, assuming that each sample is observing the pixel whose index is in pix_idx. The parameter num_of_pixels contains the number of pixels in the Healpix map, and it is used as an upper bound for the values in pix_idx. The parameter comm must be a MPI communicator, or nothing if you are not using MPI.\n\nIf comm is not nothing, the function is parallelized using MPI, and each process computes a map from its available data.  All partial maps are then combined together with MPI.Allreduce. The function returns an array containing the binned map.\n\nIf Array of structures TodNoisePropertiesis passed to the function, the output binned map will be a weighted binned map. Each sample is weighted according to the inverse white noise variance sigma^2 of the corrispondingù polarimeter. In this way, the less noisy polarimeters will count more in the estimation of the map.\n\nRequirements\n\nThe length of the arrays pix_idx and tod must be the same\n\n\n\n\n\n","category":"function"},{"location":"mapmaking/#Stripeline.baseline2map_mpi","page":"Map making","title":"Stripeline.baseline2map_mpi","text":"baseline2map_mpi(pix_idx, baselines, baseline_lengths, num_of_pixels; comm = nothing)-> noise_map\nbaseline2map_mpi(pix_idx, baselines, num_of_pixels, data_properties; comm = nothing) -> noise_map\n\nThis is a MPI based function: each MPI process computes a map from its available data.  All partial maps are then combined together with MPI.Allreduce. The function returns an array containing the binned map.\n\nIf Array of structures TodNoisePropertiesis passed to the function (instead of baseline_lengths) the output binned map will be a weighted binned map. Each sample will be weighted according to the inverse white noise variance sigma^2 of the corrisponding polarimeter. In this way, the less noisy polarimeters will count more in the estimation of the map.\n\nRequirements\n\nThe length of baselines and baseline_lengths must be the same;\nThe value sum(baseline_lengths) must be the same as the length of pix_idx.\n\n\n\n\n\n","category":"function"},{"location":"mapmaking/#Stripeline.destripe","page":"Map making","title":"Stripeline.destripe","text":"destripe(pix_idx, tod, num_of_pixels, data_properties, rank; comm = nothing, threshold = 1e-9, max_iter = 10000, save_baseline_history = false) -> DestripingResults\n\nThis MPI based function creates a map from a TOD and removes both 1/f and white noise, using the destriping technique.\n\nThe parameters passed to the function have the following meaning:\n\npix_idx: array containing the indices of the pixels visited by the instrument\ntod: the values measured by the polarimeters for each pixel (either I, Q, or U)\nnum_of_pixels: the number of pixels in the map to be  produced. This is used as an upper limit for the values in pix_idx\ndata_properties: an array of structures TodNoiseProperties,  holding information on each simulated polarimeter noise level,  number and length of 1/f baselines and total number of samples.  It can be obtained by using function build_noise_properties.\nrank: the rank of the current MPI process\ncomm: the MPI communicator object.\n\nThe following arguments are optional:\n\nthreshold is used by the conjugated-gradient algorithm. When the  residual error of the iteration goes below this value, the iteration  stops. The smaller the value, the more accurate the solution.\nmax_iter is the maximum number of iterations to be executed in the  conjugated-gradient algorithm. If the algorithm does not converge  within this number of iterations, the process will quit without  having reached the convergence threshold (see the threshold  keyword above).\nIf save_baseline_history is true, the return value will contain the sequence of baselines tested by the CG algorithm. Each MPI process will hold its own baselines.\n\nThe function returns a DestripingResults object containings the destriped map, the sequence of baselines, and other information describing the convergence of the CG algorithm.\n\nRemarks\n\nThe length of the arrays pix_idx and tod must be the same;\nIf you do not specify comm, no MPI will be used\n\n\n\n\n\n","category":"function"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"DocTestSetup = quote\n    using Stripeline\nend","category":"page"},{"location":"scanning/#Simulating-the-scanning-strategy","page":"Scanning strategy","title":"Simulating the scanning strategy","text":"","category":"section"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"Stripeline includes a set of tools to simulate the observation of the sky by the telescope. The way a telescope observes the sky is called scanning strategy, and it is obviously one of the most basic and important task in any simulation of data taking.","category":"page"},{"location":"scanning/#Strip's-location-and-movements","page":"Scanning strategy","title":"Strip's location and movements","text":"","category":"section"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"The Strip telescope, unlike most of the optical telescopes, performs a regular, uninterrupted movement using the so-called azimuth motor, a wheel that makes the whole structure spin around its gravity axis. The height of the telescope can be varied by another motor (the altitude motor), but we foresee that it will be always kept at the same angle during spinning. The following animation shows how the two motor operates: first, the altitude motor moves by roughly 20°, and then the azimuth motor starts spinning.","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"<iframe\n    src=\"https://www.youtube.com/embed/01P_5aCmST0\"\n    frameborder=\"0\"\n    allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\"\n    allowfullscreen>\n</iframe>","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"The red laser beam shows the so-called boresight direction, which points toward the position being observed on the celestial sphere. The motion of the telescope, coupled with the spinning of the Earth, produces a characteristic pattern in the sequence of points on the celestial sphere that are observed by Strip. To understand this pattern, you must be aware that Strip will be deployed to Tenerife, one of the Canarian Islands (Spain), a location in the Northern Emisphere, at latitude ≈28°N:","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"<iframe\n    width=\"425\"\n    height=\"350\"\n    frameborder=\"0\"\n    scrolling=\"no\"\n    marginheight=\"0\"\n    marginwidth=\"0\"\n    src=\"https://www.openstreetmap.org/export/embed.html?bbox=-16.525948047637943%2C28.29287470104711%2C-16.497623920440677%2C28.309538133052932&amp;layer=mapnik\"\n    style=\"border: 1px solid black\">\n</iframe>\n<br/>\n<small>\n    <a href=\"https://www.openstreetmap.org/#map=16/28.3012/-16.5118\">Enlarged map</a>\n</small>","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"(The coordinates of the site, as well as its elevation, are available in the constants TENERIFE_LATITUDE_DEG, TENERIFE_LONGITUDE_DEG, and TENERIFE_HEIGHT_M.) Now, consider the animation of the spinning telescope as seen from space:","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"<iframe\n    src=\"https://www.youtube.com/embed/WKibmFWynbM\"\n    frameborder=\"0\"\n    allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\"\n    allowfullscreen>\n</iframe>","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"As above, the red vector shows the boresight direction, while the green vector shows the zenith at Tenerife (the direction along the gravitational force vector, pointings towards the sky); the yellow direction represents the direction of the beam polarizer, and it is a parameter used to convert the Stokes parameters Q and U to celestial coordinates. Remembering that the red beam shows where the telescope is looking, this scanning strategy observes a circumference in the sky. However, because Earth rotates once every 24 hours (much faster in the animation than in reality!), the observation pattern is a spiral that covers a «strip» on the sky, whose apparent height is roughly equal to twice the angle of the boresight wheel.","category":"page"},{"location":"scanning/#Simulating-the-motion-of-the-telescope-wheels","page":"Scanning strategy","title":"Simulating the motion of the telescope wheels","text":"","category":"section"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"We'll now use the tools provided by Stripeline to simulate the region of the sky that is observed by the telescope. You can type the following commands in a Jupyter notebook, if you have installed the awesome IJulia package; otherwise, you can write them directly on Julia's command line. Let's load the packages we'll need to run the simulation: Plots enables the plot function, Healpix implements the Healpix tessellation algorithm on the sphere, and yours truly Stripeline:","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"using Plots\nusing Healpix\nusing Stripeline","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"Since Stripeline is a simulator, it has been designed to be extremely versatile: the angles of the two wheels discussed above (the elevation wheel and the azimuth wheel) can be specified as arbitrary functions of time, expressed in seconds:","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"telescope_motors(time_s) = (0.0, deg2rad(20.0), timetorotang(time_s, 1))\nnothing; # hide","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"Here we use the handy function timetorotang to compute 2pinu t, the angle as a function of time for a continuous circular motion of 1 rotation per minute. This function must be passed as the first parameter to the function genpointings, which computes the direction and the observing angle for a number of points in time. The direction is encoded as a Ntimes 2 matrix containing the colatitude and the longitude in the two columns; we iterate on the N rows of this matrix and set each pixel in a Healpix map to this value, taking advantage of Healpix.jl's function ang2pix:","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"function project_to_map(time_range, map)\n    # We discard the second return value of \"genpointings\" with \"_\":\n    # it's the orientation, but for this simple example it is not necessary\n    dirs, _ = genpointings(\n        telescope_motors,  # Angle of the three wheels as a function of time\n        Float64[0, 0, 1],  # Observing direction in the focal plane reference frame\n        time_range,        # Array of time values\n    )\n\n    # For each sample, set the corresponding pixel in the sky map to 1\n    for idx in 1:length(time_range)\n        # Extract the colatitude and the longitude from \"dirs\"\n        colat, long = dirs[idx, :]\n        pixel_index = ang2pix(map, colat, long)\n        map[pixel_index] = 1\n    end\nend\nnothing; # hide","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"It's now a matter of creating a Healpix map, wrapping the code in a call to project_to_map, and plotting the result:","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"# We create a Healpix map that represents the whole sky sphere,\n# tessellated up to some resolution NSIDE=128\nmap = Healpix.Map{Float64, RingOrder}(128)\n\n# Set the sampling time, the number of seconds used to create one\n# measurement. The real value is 0.01, but we use a larger\n# sampling time to make the simulation faster\nsampling_time_s = 0.05\n\n# Run a simulation lasting one minute (which corresponds to\n# exactly one rotation of the telescope around the azimuth axis)\nproject_to_map(0.0:sampling_time_s:60.0, map)\n\n# Plot the map, using the orthographic projection\nplot(map, orthographic)\nsavefig(\"oneminutemap.svg\"); nothing # hide","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"(Image: )","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"The result should match your expectations: considering the animation of the spinning telescope as seen from space, the sequence of points set to 1 in the map corresponds to the directions visited by the red vector during one spin. Let's re-run the animation over a longer time span, one hour; no need to re-allocate the map, as we'll simply overwrite it:","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"# Run a simulation lasting one hour (60 rotations\n# of the telescope, while the Earth slowly spins)\nproject_to_map(0.0:sampling_time_s:3600.0, map)\n\nplot(map, orthographic)\nsavefig(\"onehourmap.svg\"); nothing # hide","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"(Image: )","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"Running the simulation over one hour shows the effect of the Earth's rotation, which makes the circle move Eastward.","category":"page"},{"location":"scanning/#A-more-complex-example","page":"Scanning strategy","title":"A more complex example","text":"","category":"section"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"In the examples above, we set to 1 the pixels in the map that were observed by the Strip telescope at least one time. A much more informative way of plotting these maps is to count the number of times a pixel has been observed, as typically one wants to make several observations and then average them together to produce one estimate with its own error bar. The number stored in each pixel is the so-called hit count for that pixel, and it is related to the overall amount of time spent by the telescope observing that direction.","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"Let's modify the function project_to_map so that it increments the value of a pixel:","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"function project_to_map(time_range, map)\n    dirs, _ = genpointings(telescope_motors, Float64[0, 0, 1], time_range)\n\n    for idx in 1:length(time_range)\n        colat, long = dirs[idx, :]\n        pixel_index = ang2pix(map, colat, long)\n\n        # Increment the \"hit count\"\n        map[pixel_index] += 1\n    end\nend\nnothing; # hide","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"Now let's recreate the simulation above, using the @animate macro to produce a movie of the hit count as time passes:","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"# Reset the map, so that each pixel is set to zero\nmap[:] .= 0\n\n# Create one frame per each minute of observation\nanim = @animate for minute in 0:60\n    # Start and end times of this minute; note that we drop\n    # the last sample from \"end_time_s\", as it will be included\n    # in the next iteration\n    start_time_s = minute * 60\n    end_time_s = (minute + 1) * 60 - sampling_time_s\n\n    project_to_map(start_time_s:sampling_time_s:end_time_s, map)\n\n    # The keyword \"clim\" fixes the lower and upper limits of the\n    # color bar. Avoiding to do so results in the color scale flickering\n    # between frames in the animation (try it!)\n    plot(map, orthographic, clim=(0, 100))\nend\n\n# Save the result into an animated GIF file, with 10 frames per second.\n# As one frame in our animation lasts one minute, this means that each\n# second in the animation corresponds to 10 minutes\ngif(anim, \"scanning-animation.gif\", fps = 10)","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"Note that most of the pixels are observed a few times, but those on the uppermost and lowermost part of the strip have a much higher hit count. We clipped the maximum value shown in the color bar to 100, but we can make Julia compute the maximum value in the map:","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"println(\"The maximum hit count in the map is \", maximum(map))","category":"page"},{"location":"scanning/#A-more-complex-example-2","page":"Scanning strategy","title":"A more complex example","text":"","category":"section"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"So far, we have simulated the behavior of the Strip instrument in quite ideal conditions: we started each simulation from time t = 0, without specifying an absolute date.","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"The function genpointings accepts a starting time expressed as a Julian date; in this case, it uses a slower algorithm to find the direction and orientation of the telescope that considers several other effects:","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"The position of the Earth with respect to the Sun;\nThe precession of the Earth's  axis;\nThe  nutation of  the Earth's axis due to other bodies in the Solar System;\nStellar aberration;\nAtmospheric  refraction,  although this computation is valid only for visible wavelengths  and should therefore not be used when simulating observations done  by Strip detectors (which operates at microwave lengths).","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"To specify times, you can use the functions jdcnv and daycnv from AstroLib:","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"using AstroLib, Dates\n\n# Assume that the simulation starts on January, 1st 2022, 15:00:00\nstart_day = DateTime(2022, 1, 1, 15, 0, 0))\n\nprintln(\"The simulation starts from JD $start_day\")\n\ndirs, orientations = genpointings(\n    telescope_motors,\n    Float64[0, 0, 1],\n    0:sampling_time_s:60.0,\n    start_day,   # We specify here the JD when the simulation starts\n)","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"Passing start_day will make genpointings use a much slower algorithm to compute the pointings; you should use this syntax only if your simulation really needs the increased precision. Typical examples where you really want to do this are the following:","category":"page"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"You want to estimate when and how long an object in the sky (e.g.,  the Crab Nebula,  Jupiter) will be visible  by Strip;\nA variation of the previous point is to compute when bright  objects (Sun, Moon, etc.) might be dangerously close to the  boresight direction of the telescope, in order to decide when  the telescope will need to be shut down to prevent overheating or  saturations in the detectors.\nYou want to produce a sky map to be compared with those of other  experiments running at the same time as Strip;\nYou want to assess how much effects like precession, nutation, and  aberration affect the measurements.","category":"page"},{"location":"scanning/#Reference-documentation","page":"Scanning strategy","title":"Reference documentation","text":"","category":"section"},{"location":"scanning/","page":"Scanning strategy","title":"Scanning strategy","text":"TENERIFE_LATITUDE_DEG\nTENERIFE_LONGITUDE_DEG\nTENERIFE_HEIGHT_M\ntelescopetoground\ngroundtoearth\ngenpointings\ntimetorotang\nnorthdir\neastdir\npolarizationangle","category":"page"},{"location":"scanning/#Stripeline.TENERIFE_LATITUDE_DEG","page":"Scanning strategy","title":"Stripeline.TENERIFE_LATITUDE_DEG","text":"Latitude of the LSPE/Strip site in Tenerife, in degrees\n\n\n\n\n\n","category":"constant"},{"location":"scanning/#Stripeline.TENERIFE_LONGITUDE_DEG","page":"Scanning strategy","title":"Stripeline.TENERIFE_LONGITUDE_DEG","text":"Longitude of the LSPE/Strip site in Tenerife, in degrees\n\n\n\n\n\n","category":"constant"},{"location":"scanning/#Stripeline.TENERIFE_HEIGHT_M","page":"Scanning strategy","title":"Stripeline.TENERIFE_HEIGHT_M","text":"Height of the LSPE/Strip site in Tenerife, in meters\n\n\n\n\n\n","category":"constant"},{"location":"scanning/#Stripeline.telescopetoground","page":"Scanning strategy","title":"Stripeline.telescopetoground","text":"telescopetoground(wheelanglesfn, time_s)\n\nReturn a quaternion of type Quaternion{Float64} representing the coordinate transform from the focal plane to the ground of the telescope. The parameter wheelanglesfn must be a function which takes as input a time, time_s, in seconds, and it must return a 3-tuple containing the angles of the following motors, measured in radians:\n\nThe boresight motor (rotation around the z axis, counterclockwise)\nThe altitude motor (rotation around the y axis, counterclockwise)\nThe ground motor (rotation around the z axis, clockwise: N→E→S→W)\n\nExample\n\ntelescopetoground(3600.0) do\n    # Boresight motor keeps a constant angle equal to 0°\n    # Altitude motor remains at 20° from the Zenith\n    # Ground motor spins at 1 RPM\n    (0.0, deg2rad(20.0), timetorotang(time_s, 1))\nend\n\n\n\n\n\n","category":"function"},{"location":"scanning/#Stripeline.groundtoearth","page":"Scanning strategy","title":"Stripeline.groundtoearth","text":"groundtoearth(groundq, time_s, latitude_deg; day_duration_s=86400.0)\n\nReturn a quaternion of type Quaternion{Float64} representing the coordinate transformation from the ground of the telescope to the Equatorial coordinate system. The parameter groundq must be a quaternion describing the coordinate transformation from the focal plane of the telescope to the ground. The parameter time_s must be a time in seconds, and latitude_deg is the latitude (in degrees, N is positive) of the location where the observation is made.\n\nThe keyword day_duration_s specifies the length of a sidereal day in seconds.\n\n\n\n\n\n","category":"function"},{"location":"scanning/#Stripeline.genpointings","page":"Scanning strategy","title":"Stripeline.genpointings","text":"genpointings!(wheelanglesfn, beam_dir, timerange_s, dirs, psi;\n              polaxis = Float64[1.0, 0.0, 0.0],\n              latitude_deg = TENERIFE_LATITUDE_DEG,\n              ground = false)\ngenpointings(wheelanglesfn, beam_dir, timerange_s;\n             polaxis = Float64[1.0, 0.0, 0.0],\n             latitude_deg = TENERIFE_LATITUDE_DEG,\n             ground = false)\ngenpointings!(wheelanglesfn, beam_dir, timerange_s, t_start, dirs, psi;\n              polaxis = Float64[1.0, 0.0, 0.0],\n              latitude_deg = TENERIFE_LATITUDE_DEG,\n              longitude_deg = TENERIFE_LONGITUDE_DEG,\n              height_m = TENERIFE_HEIGHT_M,\n              precession = true,\n              nutation = true,\n              aberration = true,\n              refraction = true)\ngenpointings(wheelanglesfn, beam_dir, timerange_s, t_start;\n             polaxis=Float64[1.0, 0.0, 0.0],\n             latitude_deg=TENERIFE_LATITUDE_DEG,\n             longitude_deg=TENERIFE_LONGITUDE_DEG,\n             height_m=TENERIFE_HEIGHT_M,\n             precession = true,\n             nutation = true,\n             aberration = true,\n             refraction = true)\n\nGenerate a set of pointing directions for a STRIP detector. Each function is provided in two flavours: the ones ending with ! save the results in the last two parameters dirs and psi, while the others automatically allocate memory and return their results as a pair (dirs, psi).\n\nThe parameter wheelanglesfn must be a function which takes as input a time in seconds and returns a 3-tuple containing the angles (in radians) of the three motors:\n\nThe boresight motor (rotation around the z axis, counterclockwise)\nThe altitude motor (rotation around the y axis, counterclockwise)\nThe ground motor (rotation around the z axis, clockwise: N→E→S→W)\n\nThe meaning of the parameters/keywords is the following:\n\nbeam_dir specifies the pointing direction of the mean (the boresight is [0, 0, 1]). It must be normalized.\ntimerange_s is an enumerable type that specifies at which times (in seconds) pointings must be computed.\nt_start is a DateTime object or a Julian date, which specifies the UTC date and time when the observation starts\nlatitude_deg is the latitude of the location where the observation is made (in degrees, North is positive). The default value is TENERIFE_LATITUDE_DEG.\nlongitude_deg is the longitude of the location where the observation is made. The default value is TENERIFE_LONGITUDE_DEG.\nheight_m is the elevation of the location where the observation is made (in meters). The default value is TENERIFE_HEIGHT_M.\nIf ground is true, the function will return a 4-tuple containing the colatitude and longitude measured in Equatorial coordinates (columns 1 and 2) and in ground coordinates (columns 3 and 4). If ground is false, only the Equatorial coordinates are computed.\npolaxis is the polarization axis; it must be normalized.\nprecession: if true (the default), the Earth's precession is taken into account.\nnutation: if true (the default), the Earth's nutation is taken into account.\naberration: if true (the default), stellar aberration is taken into account.\nrefraction: if true, refraction corrections are taken into account. As these corrections are only valid for optical wavelengths, the default is false.\n\nReturn values\n\nIf t_start is not provided, the function genpointings returns a 2-tuple containing the sky directions (a N×2 array containing declination and right ascension, in Equatorial coordinates) and the polarization angle for each time step. The function genpointings! sets the values in the last two parameters dirs and psi.\n\nIf t_start is provided, the function genpointings returns a 2-tuple (4-tuple) containing the directions (a N×2 or Nx4 array containing the colatitude and the longitude) and the polarization angles at each time step; genpointings! works as above.\n\nExamples\n\nHere is an example using the form without t_start:\n\ndir, psi = genpointings([0, 0, 1], 0:0.1:1) do time_s\n    # Boresight motor keeps a constant angle equal to 0°\n    # Altitude motor remains at 20° from the Zenith\n    # Ground motor spins at 1 RPM\n    (0.0, deg2rad(20.0), timetorotang(time_s, 1))\nend\n\nAnd here is an example using t_start; unlike the previous example, we use a lambda function instead of the do...end notation.\n\nimport Dates\n\ndirs, psi = genpointings(time_s -> (0, deg2rad(20),\n                                    timetorotang(time_s, 1)),\n                         [0, 0, 1],\n                         0:0.1:1,\n                         Dates.DateTime(2022, 01, 01, 0, 0, 0),\n                         latitude_deg=10.0,\n                         longitude_deg=20.0,\n                         height_m = 1000) do time_s\n\n\n\n\n\n","category":"function"},{"location":"scanning/#Stripeline.timetorotang","page":"Scanning strategy","title":"Stripeline.timetorotang","text":"timetorotang(time, rpm)\n\nConvert a time into a rotation angle, given the number of rotations per minute. The time should be expressed in seconds. The return value is in radians. time can either be a scalar or a vector.\n\n\n\n\n\n","category":"function"},{"location":"scanning/#Stripeline.northdir","page":"Scanning strategy","title":"Stripeline.northdir","text":"northdir(θ, ϕ)\neastdir(θ, ϕ)\n\nCompute the North/East versor for a vector. The North for a vector v is along the direction -dv/dθ, as θ is the colatitude and moves along the meridian, and the East is along dv/dϕ.\n\nExamples\n\njulia> northdir(π/2, 0) ≈ [0, 0, 1]\ntrue\njulia> eastdir(π/2, 0) ≈ [0, 1, 0]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"scanning/#Stripeline.eastdir","page":"Scanning strategy","title":"Stripeline.eastdir","text":"northdir(θ, ϕ)\neastdir(θ, ϕ)\n\nCompute the North/East versor for a vector. The North for a vector v is along the direction -dv/dθ, as θ is the colatitude and moves along the meridian, and the East is along dv/dϕ.\n\nExamples\n\njulia> northdir(π/2, 0) ≈ [0, 0, 1]\ntrue\njulia> eastdir(π/2, 0) ≈ [0, 1, 0]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"scanning/#Stripeline.polarizationangle","page":"Scanning strategy","title":"Stripeline.polarizationangle","text":"polarizationangle(northdir, eastdir, poldir)\n\nCalculate the polarization angle projected in the sky in IAU conventions. The parameters northdir and eastdir must be versors that point towards the North and East, respectively; poldir must be a versor that identify the polarization direction projected in the sky. The return value is in radians, and it is zero if the polarization angles points toward East, π/2 if it points toward North, etc.\n\nExamples\n\njulia> polarizationangle([0, 0, 1], [0, 1, 0], [0, 1, 0])\n0.0\njulia> polarizationangle([0, 0, 1], [0, 1, 0], [0, 0, 1]) |> rad2deg\n90.0\njulia> polarizationangle([0, 0, 1], [0, 1, 0], [0, 0, -1]) |> rad2deg\n-90.0\n\n\n\n\n\n","category":"function"}]
}
