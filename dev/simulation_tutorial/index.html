<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Full-scale simulation tutorial · Stripeline.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Stripeline.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../basic/">Basic functions</a></li><li><a class="tocitem" href="../instrumentdb/">Instrument database</a></li><li><a class="tocitem" href="../tod/">Time-ordered data</a></li><li><a class="tocitem" href="../scanning/">Scanning strategy</a></li><li><a class="tocitem" href="../acquisition/">Data acquisition</a></li><li><a class="tocitem" href="../mapmaking/">Map making</a></li><li class="is-active"><a class="tocitem" href>Full-scale simulation tutorial</a><ul class="internal"><li><a class="tocitem" href="#.-Simple-Case:-small-TOD"><span>1. Simple Case: small TOD</span></a></li><li><a class="tocitem" href="#.-General-Case"><span>2. General Case</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Full-scale simulation tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Full-scale simulation tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lspestrip/Stripeline.jl/blob/master/docs/src/simulation_tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Simulation-tutorial"><a class="docs-heading-anchor" href="#Simulation-tutorial">Simulation tutorial</a><a id="Simulation-tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-tutorial" title="Permalink"></a></h1><p>The aim of this tutorial is to describe how you can use the functions provided by Stripeline to perform a complete simulation of the LSPE/STRIP experiment.</p><p><strong>Caution</strong>: this page contains some syntax that has been superseded. Refer to the file <code>examples/e2e_simulation.jl</code> for an updated version of this example that runs under Julia 1.6.</p><p>So far, the simulation includes:</p><ul><li><p>simulation of the telescope scanning the sky</p></li><li><p>simulation of noise (white and 1/f)</p></li><li><p>production of a tod </p></li><li><p>production of a map by using the destriping technique</p></li></ul><p>Two examples will be presented: </p><ol><li><p>a simple case, in which we produce and analyze a very small TOD (1 day observation).  You should refer to this case if you want to use a Jupyter Notebook to perform preliminary studies (since you cannot use MPI in a notebook).</p></li><li><p>a more general and realistic case, suitable also for the production of large TODs.  In this case it will be necessary to use MPI functions.</p></li></ol><h2 id=".-Simple-Case:-small-TOD"><a class="docs-heading-anchor" href="#.-Simple-Case:-small-TOD">1. Simple Case: small TOD</a><a id=".-Simple-Case:-small-TOD-1"></a><a class="docs-heading-anchor-permalink" href="#.-Simple-Case:-small-TOD" title="Permalink"></a></h2><ol><li>First of all, you should import the following packages:</li></ol><pre><code class="nohighlight">import Healpix
import Random
import CorrNoise
import Stripeline
const Sl = Stripeline
using FITSIO</code></pre><p>In this simple case we can avoid using MPI, but we need the following line:</p><pre><code class="nohighlight">comm = missing
</code></pre><p>This is because some of the functions we will use (e.g., the <code>destripe</code> function) require the MPI communicator as input parameter.</p><ol><li>Then, you can start by setting the simulation parameters:</li></ol><ul><li><p>the number of days of observation</p></li><li><p>the number of polarimeters to simulate</p></li><li><p>the sampling frequency (Hz)</p></li><li><p>the length of 1/f baselines (s) as input for the destriper</p></li><li><p>the NSIDE you prefer for your output map</p></li><li><p>the temperature of the sky signal (K)</p></li><li><p>the temperature of the atmosphere (K)</p></li><li><p>the temperature of the telescope (K)</p></li><li><p>the noise temperature of the polarimeters (K)</p></li><li><p>the knee frequency of the polarimeters (Hz)</p></li><li><p>the bandwidth of the polarimeters (Hz)</p></li></ul><p>N.B. In the current version of the simulation we consider all polarimeters identical in properties.</p><pre><code class="nohighlight">#Simulation parameters

days_of_observation = 1
num_of_polarimeters = 1
baseline_length_s = 10  
fsamp_hz = 40
NSIDE = 256

tcmb_k = 3
tatm_k = 15
ttel_k = 3
tnoise_k = 35
fknee_hz = 0.01
β_hz = 7e9
</code></pre><ol><li>At this point, you can compute some parameters we will need later: the total observation time (in s), the integration time, the total system temperature and the receiver sensitivity.</li></ol><pre><code class="nohighlight">total_time = days_of_observation * 24 * 3600
tsys_k = tnoise_k + tatm_k + ttel_k + tcmb_k
τ_s = 1 / fsamp_hz
σ_k = (tsys_k / sqrt(β_hz * τ_s))</code></pre><ol><li>Open now the input map, that is to say the sky you want to scan with your instrument.  You can find two example input maps (with two different resolutions) <a href="https://github.com/lspestrip/Stripeline.jl/tree/master/test/testfiles">here</a>.</li></ol><p>Those maps have been produced with <a href="https://github.com/bthorne93/PySM_public">PySM</a> and are specific for the STRIP case: they are 43 GHz maps of polarized emission only (cmb, synchrotron and dust).  If you want to produce your own input map, you can use this python <a href="https://github.com/silviacaprioli/PySMforSTRIP/blob/master/PySMmap_production.py">script</a>.</p><pre><code class="nohighlight">inputmap = Healpix.readMapFromFITS(raw&quot;PySM_inputmap_nside256.fits&quot;, 2 , Float64)
inputmap_resol = inputmap.resolution

resol = Healpix.Resolution(NSIDE) #desired resolution for output map
num_of_pixels = resol.numOfPixels</code></pre><ol><li>You can now scan the input map according to your scanning strategy, thus producing the pure signal &quot;sky TOD&quot;.  In this case, we use the nominal scanning strategy for STRIP (Tenerife latitude, 20° of elevation angle, 1 RPM)</li></ol><pre><code class="nohighlight">#Generate sky tod

times = 0:τ_s: (total_time-τ_s)
(dirs, ψ) = Sl.genpointings([0., 0., 1.], times; latitude_deg=28.29) do time_s
    return (0.0, deg2rad(20.0), Sl.timetorotang(time_s, 1.))
end

pix_idx_inputmap = Healpix.ang2pixRing.(Ref(inputmap_resol), dirs[:, 1], dirs[:, 2])
pix_idx = Healpix.ang2pixRing.(Ref(resol), dirs[:, 1], dirs[:, 2])

sky_tod = inputmap.pixels[pix_idx_inputmap]</code></pre><ol><li>Now you should add noise to your sky tod. We simulate both white noise and 1/f noise, in accordance with the noise properties of the polarimeters specified at the beginning of the script.  To do that, we use the functions of the module <a href="https://github.com/ziotom78/CorrNoise.jl">CorrNoise.jl</a>.</li></ol><pre><code class="nohighlight">#Generate noise

seed = rand(1:1000)
rng = CorrNoise.OofRNG(CorrNoise.GaussRNG(Random.MersenneTwister(seed)), -1, 1.15e-5, fknee_hz, fsamp_hz);
noise_tod = [CorrNoise.randoof(rng) * σ_k for i in 1:(fsamp_hz * total_time)]
</code></pre><ol><li>Finally, you can get the final, realistic TOD just by doing:</li></ol><pre><code class="nohighlight">tod = sky_tod + noise_tod</code></pre><ol><li>Once you have completed the simulation, you can do data analysis! For instance, you can call the destriper and clean the map from 1/f noise.</li></ol><p>(N.B. the destriper needs in input an array containing the lengths of all 1/f baselines.  For the sake of semplicity, we consider baselines of equal length).</p><pre><code class="nohighlight">#Run the destriper

baseline_len = repeat([baseline_length_s*fsamp_hz],Int64(total_time/baseline_length_s))

(destr_map, a) = Sl.destripe(pix_idx, tod, num_of_pixels, baseline_len, comm)</code></pre><p>The output of the destriper are:</p><ul><li><code>destr_map</code> : the destriped map, cleaned from 1/f noise.</li><li><code>a</code> : the baselines array.</li></ul><ol><li>If you wish, you can finally convert the destriped map (Array{Float64,1}) into a HEALPix map and save it in a FITS file:</li></ol><pre><code class="nohighlight">#save file 

mapfile = Healpix.Map{Float64,Healpix.RingOrder}(NSIDE)
mapfile.pixels = destr_map

Healpix.saveToFITS(mapfile, &quot;destriped_map.fits&quot;, typechar = &quot;D&quot;)</code></pre><p>To run this script you can use the following command:</p><pre><code class="nohighlight">julia simplecase.jl</code></pre><h2 id=".-General-Case"><a class="docs-heading-anchor" href="#.-General-Case">2. General Case</a><a id=".-General-Case-1"></a><a class="docs-heading-anchor-permalink" href="#.-General-Case" title="Permalink"></a></h2><p>In realistic cases, TODs are really huge (millions or billions of samples!).  This means a lot of memory allocation. In the case of Strip, 49 polarimeters observing the sky for 2 years with a sampling frequency of 100 Hz produce 300 billions of samples, which means about 2 Terabytes of memory allocation!</p><p>It is much more than a single computer can support. It is thus compulsory to split the TOD simulation and analysis between different computing units, by using MPI.</p><p>Let&#39;s go through all the points of the simulation and see how things change:</p><ol><li>You have to add the MPI package to your dependencies. </li></ol><pre><code class="nohighlight">import MPI

import Healpix
import Random
import CorrNoise
import Stripeline
const Sl = Stripeline
using FITSIO
</code></pre><ol><li>Nothing changes with respect to the case above.</li></ol><pre><code class="nohighlight">#Simulation parameters

days_of_observation = 1
num_of_polarimeters = 1
baseline_length_s = 10  
fsamp_hz = 40
NSIDE = 256

tcmb_k = 3
tatm_k = 15
ttel_k = 3
tnoise_k = 35
fknee_hz = 0.01
β_hz = 7e9
</code></pre><ol><li>You should add the computation of the total number of samples per polarimeter and total number of baselines for polarimeter, which we will need later.</li></ol><pre><code class="nohighlight">total_time = days_of_observation * 24 * 3600
tsys_k = tnoise_k + tatm_k + ttel_k + tcmb_k
τ_s = 1 / fsamp_hz
σ_k = (tsys_k / sqrt(β_hz * τ_s))

samples_per_pol = total_time*fsamp_hz 
baselines_per_pol = Int64(total_time/baseline_length_s)</code></pre><ol><li>Nothing changes.</li></ol><pre><code class="nohighlight">inputmap = Healpix.readMapFromFITS(raw&quot;PySM_inputmap_nside256.fits&quot;, 2 , Float64)
inputmap_resol = inputmap.resolution

resol = Healpix.Resolution(NSIDE) #desired resolution for output map
num_of_pixels = resol.numOfPixels</code></pre><p>Before scanning the input map we have to conveniently split the TOD production among the available computing units.  First of all, we need to initialize MPI:</p><pre><code class="nohighlight">MPI.Init()

comm = MPI.COMM_WORLD
rank = MPI.Comm_rank(comm)
commsize = MPI.Comm_size(comm) 
</code></pre><p>Then, we can proceed with the TOD splitting.</p><p>The splitting is done in a way that each rank gets a whole number of 1/f baselines to simulate and that the TOD chunks are of as similar length as possible.</p><p>We also need to tell to each unit which detector to simulate and from which to which time.  By using the <code>get_chunk_properties</code> function, we can obtain these information for the current rank.</p><pre><code class="nohighlight">#Split tod production 

baselines_per_process = Sl.split_into_n(num_of_polarimeters*baselines_per_pol, commsize)
chunks = Sl.split_tod_mpi(total_time, baseline_length_s, baselines_per_process, commsize)
this_rank_chunk = chunks[rank+1]

(detector_number, first_time, last_time, num_of_baselines, num_of_samples) = Sl.get_chunk_properties(chunks, baseline_length_s, fsamp_hz, rank)
</code></pre><ol><li>Concerning the production of the sky TOD, of course each computing unit will produce its own partial TOD using the information obtained before.  A loop on detectors has been added, since in the general case the simulation involves more than one detector, and moreover, each rank may have to simulate partial tods for different detectors.</li></ol><pre><code class="nohighlight">#Generate sky tod

pix_idx = Int64[]
pix_idx_inputmap = Int64[]
sky_tod = Float64[]


for i in 1:length(this_rank_chunk)   #loop on detectors

    #generate pointings according to STRIP scanning strategy

    times = first_time[i]:τ_s:last_time[i]

 
    (dirs, ψ) = Sl.genpointings([0., 0., 1.], times; latitude_deg=28.29) do time_s
        return (0.0, deg2rad(20.0), Sl.timetorotang(time_s, 1.))
    end

    partial_pix_idx_inputmap = Healpix.ang2pixRing.(Ref(inputmap_resol), dirs[:, 1], dirs[:, 2])
    partial_pix_idx = Healpix.ang2pixRing.(Ref(resol), dirs[:, 1], dirs[:, 2])

    #build the sky tod
    partial_sky_tod = inputmap.pixels[partial_pix_idx_inputmap]
    global sky_tod = append!(sky_tod, partial_sky_tod)
    global pix_idx = append!(pix_idx, partial_pix_idx)
end
</code></pre><ol><li>To generate noise, you e can use the <code>generate_noise_mpi</code> function, which directly returns the partial noise TOD for the current rank.</li></ol><pre><code class="nohighlight">#Generate noise

noise_tod = Sl.generate_noise_mpi(chunks, baselines_per_process, baseline_length_s, fsamp_hz, σ_k, fknee_hz, rank, comm)</code></pre><ol><li>nothing changes.</li></ol><pre><code class="nohighlight">tod = sky_tod + noise_tod</code></pre><ol><li>nothing changes apart from <code>baseline_len</code> definition (since now different units can have a different amount of baselines to compute).</li></ol><p>The <code>destripe</code> function already takes into account the presence of multiple computing units: each partial TOD is loaded separately and partial maps are build, but then MPI functions are called to make different ranks &quot;talk together&quot; in order to obtain in output a single global destriped map.</p><pre><code class="nohighlight">#Run the destriper

baseline_len = repeat([baseline_length_s*fsamp_hz], baselines_per_process[rank+1])
(destr_map, a) = Sl.destripe(pix_idx, tod, num_of_pixels, baseline_len, comm)</code></pre><ol><li>If you want to save the destriped map in a .fits file, you should make just one rank do that.</li></ol><pre><code class="nohighlight">#save file 

if(rank==0)
    mapfile = Healpix.Map{Float64,Healpix.RingOrder}(NSIDE)
    mapfile.pixels = destr_map
    Healpix.saveToFITS(mapfile, &quot;destriped_map.fits&quot;, typechar = &quot;D&quot;)
end</code></pre><ol><li>Finally, end your script by terminating the calling to MPI environment.</li></ol><pre><code class="nohighlight">MPI.Finalize()</code></pre><p>To run this script, you can use the following code (using 3 MPI processes):</p><pre><code class="nohighlight">mpirun -n 3 julia generalcase.jl</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../mapmaking/">« Map making</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.3 on <span class="colophon-date" title="Tuesday 4 October 2022 14:25">Tuesday 4 October 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
