<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Data acquisition · Stripeline.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Stripeline.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../basic/">Basic functions</a></li><li><a class="tocitem" href="../instrumentdb/">Instrument database</a></li><li><a class="tocitem" href="../scanning/">Scanning strategy</a></li><li class="is-active"><a class="tocitem" href>Data acquisition</a></li><li><a class="tocitem" href="../mapmaking/">Map making</a></li><li><a class="tocitem" href="../simulation_tutorial/">Full-scale simulation tutorial</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Data acquisition</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Data acquisition</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lspestrip/Stripeline.jl/blob/master/docs/src/acquisition.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Simulating-data-acquisition"><a class="docs-heading-anchor" href="#Simulating-data-acquisition">Simulating data acquisition</a><a id="Simulating-data-acquisition-1"></a><a class="docs-heading-anchor-permalink" href="#Simulating-data-acquisition" title="Permalink"></a></h1><p>An essential part of Strip polarimeters is the set of four Analogue-to-Digital Converters (ADC) that measure input voltages as 20-bit digital numbers. This process is called <em>quantization</em>, and it is a non-invertible operation that causes loss of information. Ideal ADCs perform a linear operation (modulo a rounding operation), but real-world components are never perfectly linear.</p><p>Because of the fact that CMB experiments like Strip measure brightness temperatures, Stripeline models ADCs as devices that convert temperatures into ADUs, neglecting the fact that Strip polarimeters convert incoming fluxes into voltages.</p><p>Stripeline offers a few functions to simulate the behaviour of an ADC. The simulation of ADC behaviour is useful to estimate the impact of quantization and non linearities. The following schema show how things work:</p><p><img src="../assets/adc_functions.svg" alt/></p><p>Function <a href="#Stripeline.adc_response"><code>adc_response</code></a> takes a temperature as input, and it produces the output that would be emitted by an ADC. The function <a href="#Stripeline.adc_inv_response"><code>adc_inv_response</code></a> performs the reverse transformation: it converts a digital number back to a temperature. Function <a href="#Stripeline.adc_filter"><code>adc_filter</code></a> combines the two functions: it takes a temperature as input, and it returns the temperature that has been measured by the ADC, including the effect of quantization and non linearities.</p><p>An important difference between <code>adc_response</code> and <code>adc_inv_response</code> is the fact that <code>adc_response</code> considers non linearities, while <code>adc_inv_response</code> does not.</p><article class="docstring"><header><a class="docstring-binding" id="Stripeline.ADC" href="#Stripeline.ADC"><code>Stripeline.ADC</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A structure representing the configuration of an Analogue-to-Digital Converter (ADC). To simplify things, we assume that the ADC is fed with some <em>temperature</em>, instead of a voltage. In this case we can avoid dealing with the calibration from Volt to Kelvin, which is seldom useful in simulations.</p><p>The equation used to model the ADC is the following:</p><pre><code class="nohighlight">x(V) = round(gain_k_over_adu * (V - offset_k)) + zero_point_adu</code></pre><p>and the output is clipped within a user-defined range. The following fields are available:</p><ul><li><code>offset_k</code></li><li><code>gain_k_over_adu</code></li><li><code>zero_point_adu</code></li><li><code>min_output_adu</code>: output values below this will be clipped</li><li><code>max_output_adu</code>: output values above this will be clipped</li><li><code>non_linearities_x_adu</code>: see below</li><li><code>non_linearities_y_adu</code>: see below</li></ul><p>Non linearities must be specified using the two arrays <code>non_linearities_x_adu</code> and <code>non_linearities_y_adu</code>. For each input voltage fed to the ADC, a non linearity is applied to the output according to the following algorithm:</p><ul><li>The function computes the ideal output (i.e., without non linearities);</li><li>It checks if the value of the ideal output is found in the array <code>non_linearities_x_adu</code>;</li><li>If the value is found, add the corresponding value in the array <code>non_linearities_y_adu</code> (i.e., the element with the same index as the element in <code>non_linearities_x_adu</code>) to the ideal output;</li><li>If the value is not found, but it falls within two consecutive values, use a linear interpolation;</li><li>If the value is smaller than the first element or larger than the last element in <code>non_linearities_x_adu</code>, do not apply any correction to the output.</li></ul><p>It is <strong>fundamental</strong> that <code>non_linearities_x_adu</code> is sorted in ascending order, and that the order of the in elements <code>non_linearities_y_adu</code> matches the order in <code>non_linearities_x_adu</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lspestrip/Stripeline.jl/blob/b741ff9b920f9118c30c0c890f96d4bcc20f051d/src/adc.jl#L5-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stripeline.optimized_adc" href="#Stripeline.optimized_adc"><code>Stripeline.optimized_adc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">optimized_adc(; min_input_k = 0.0, max_input_k = 100.0, dynamic_range = 0.35, nbits = 20, non_linearities_x_adu = Float64[], non_linearities_y_adu = Float64[])</code></pre><p>Return an object of type <code>ADC</code> that is optimized to measure temperatures between <code>min_input_k</code> and <code>max_input_k</code>. The ADC is configured to return <em>signed</em> numbers in the range -2^nbits…2^nbits.</p><p>The function accepts the following keywords:</p><ul><li><code>min_input_k</code>: temperature that should trigger the lowest output within the dynamic range</li><li><code>max_input_k</code>: temperature that should trigger the lowest output within the dynamic range</li><li><code>dynamic_range</code>: pure number in the interval 0…1 that specifies the dynamic range of the output</li><li><code>nbits</code>: number of bits used by the ADC</li><li><code>non_linearities_x_adu</code>: same parameter used in the constructor for <code>ADC</code></li><li><code>non_linearities_y_adu</code>: same parameter used in the constructor for <code>ADC</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lspestrip/Stripeline.jl/blob/b741ff9b920f9118c30c0c890f96d4bcc20f051d/src/adc.jl#L65-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stripeline.adc_response" href="#Stripeline.adc_response"><code>Stripeline.adc_response</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">adc_response(adc::ADC, input_k; include_non_linearities = true)</code></pre><p>Simulate the response of an ADC on some voltage <code>input_k</code>. If <code>include_non_linearities</code> is <code>true</code>, non-linearities specified in <code>adc</code> will be considered; otherwise, the ADC will be assumed to be ideal.</p><p>See also <a href="#Stripeline.adc_inv_response"><code>adc_inv_response</code></a> for the (pseudo)inverse function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lspestrip/Stripeline.jl/blob/b741ff9b920f9118c30c0c890f96d4bcc20f051d/src/adc.jl#L99-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stripeline.adc_inv_response" href="#Stripeline.adc_inv_response"><code>Stripeline.adc_inv_response</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">adc_inv_response(adc::ADC, input_adu)</code></pre><p>Apply the inverse transformation of an ADC to get some voltage from a digital measurement in ADU.This function assumes that the ADC is ideal, i.e., that it does not have non-linearities.</p><p>See also <a href="#Stripeline.adc_response"><code>adc_response</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lspestrip/Stripeline.jl/blob/b741ff9b920f9118c30c0c890f96d4bcc20f051d/src/adc.jl#L134-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stripeline.adc_filter" href="#Stripeline.adc_filter"><code>Stripeline.adc_filter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">adc_filter(adc::ADC, input_k; include_non_linearities = true)</code></pre><p>Simulate the measurement of the temperature <code>input_k</code> through the ADC <code>adc</code>. The result is still a temperature, after it has been converted into ADUs by the ADC and then converted back to a temperature again. If non-linearities are specified in <code>adc</code>, they will be applied only to the K→ADU transformation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lspestrip/Stripeline.jl/blob/b741ff9b920f9118c30c0c890f96d4bcc20f051d/src/adc.jl#L147-L154">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../scanning/">« Scanning strategy</a><a class="docs-footer-nextpage" href="../mapmaking/">Map making »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.3 on <span class="colophon-date" title="Wednesday 20 October 2021 13:16">Wednesday 20 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
