export generate_noise_mpi

import CorrNoise
using Random
using FITSIO


try
    import MPI
catch
end 

"""
This structure holds informations about a certain chunk of data produced by a certain MPI process to send to another MPI process.

Field              | Type           | Meaning
:----------------- |:-------------- |:------------------------------------------------------------
`pol_number`       | Int            | ID number of the polarimeter
`first_idx`        | Int            | Index of the first element ofthe chunk
`last_idx`         | Int            | Index of the last element of the chunk
`dest_rank`        | Int            | Number of destination rank 


# Example
Suppose that the following array of data: [1, 10, 20, 3, 4, 5, 7]
is measured by the polarimeter number 2.
If the chunk [20, 3, 4] needs to be sent to rank number 3, the corresponding structure will be:

chunk_to_send(2, 3, 5, 3)
"""
struct chunk_to_send
    pol_number ::Int
    first_idx::Int
    last_idx::Int
    dest_rank::Int
end 



function generate_noisechunks_to_send(chunks, baseline_length_s, fsamp_hz, total_number_of_polarimeters)

    commsize = length(chunks)
    noisechunks_to_send = []
 
    for cur_rank in 0:(commsize-1) #loop on ranks
        pol_cur_rank  = cur_rank+1 #polarimeter assigned to cur_rank for noise production
        chunk_cur_rank = []
 
        #Only the first "total_number_of_polarimeters" ranks will generate noise, so they will have something to send.
        if  0 <= cur_rank < total_number_of_polarimeters   
            for i in 1:length(chunks) #loop on chunks
                rank_it = i-1
                for j in 1:length(chunks[i]) #loop on detectors per rank
                    if chunks[i][j].pol_number == pol_cur_rank #if cur_rank is going to produce noise for the "correct" polarimeter
                        first_idx = (chunks[i][j].first_idx-1)*baseline_length_s*fsamp_hz+1
                        last_idx = first_idx + chunks[i][j].num_of_elements*baseline_length_s*fsamp_hz -1
                        dest_rank = rank_it
                        chunk = chunk_to_send(pol_cur_rank, first_idx, last_idx, dest_rank)
                        chunk_cur_rank = append!(chunk_cur_rank, [chunk])
                    end
                end
            end
            noisechunks_to_send= append!(noisechunks_to_send, [chunk_cur_rank])
        end 
    end

    return noisechunks_to_send

end




"""
    function generate_noise_mpi(chunks, baseline_length_s, baselines_per_process, fsamp_hz, σ_k, fknee_hz, rank, comm)

    This MPI based function can be used to generate white noise and 1/f noise when the simulation is splitted in various MPI processes.

    It requires in input:
    - the data chunks (which can be obtained by using the function `split_tod_mpi`)
    - the array containing the number of 1/f baselines to simulate for each process.
            It can be obtained by using the function `split_into_n` in the following way:

            split_into_n(num_of_polarimeters*baselines_per_pol, num_of_MPI_proc)
                
            where baselines_per_pol = Int64(total_time/baseline_length_s) is the number of baselines of each polarimeter
    - the length (in seconds) of each 1/f noise baseline
    - the total duration (in seconds) of data acquisition
    - the sampling frequency (in Hz)
    - an array containing the RMS of the temperature (in K) for each polarimeter, σ_k[i]= tsys_k[i] / sqrt(β_hz[i] * τ_s)
    - an array containing the knee frequency (in Hz) for each polarimeter
    - an array containing the oof slope for each polarimeter
    - the MPI communicator
    - the random generator seed, as optional argument.

    It returns the noise TOD for the current rank. 
    
    The function behaves differently according to the number of processes used:

        1. If the number of processes is greater than the number of polarimeters:
           the first "number of polarimeters" processes will simultaneously produce the noise, one process for one polarimeter 
           (rank 0 for pol.1, rank 1 for pol.2 and so on).
           After that, the noise is redistributed between the ranks according to the input chunk structure.


        2. If the number of processes is lesser than the number of polarimeters,
           Each partial noise TOD is generated by rank 0 and then sent to the correspondent rank. 

    N.B. if you want to use this function without MPI, remember to put rank = 0 and comm = missing


"""
function  generate_noise_mpi(chunks, baselines_per_process, baseline_length_s, total_time, fsamp_hz, σ_k, fknee_hz, slope, rank, comm, input_seed = missing)
    
    total_number_of_polarimeters = length(σ_k)
    commsize = length(chunks)

    if ismissing(input_seed) father_seed = rand(1:10000) else father_seed = input_seed end
    Random.seed!(father_seed)
    seeds = Int64[rand(1:10000) for i in 1:total_number_of_polarimeters]
    

    ################ IF MORE PROCESSES THAN POLARIMETERS ################
    if(commsize >= total_number_of_polarimeters) 
      
        noisechunks_to_send = generate_noisechunks_to_send(chunks, baseline_length_s, fsamp_hz, total_number_of_polarimeters)

        ##### NOISE PRODUCTION #####
        pol_number = rank+1 
        pol_noise = Float64[]
        noise = Array{Float64}(undef, baselines_per_process[rank+1]*baseline_length_s*fsamp_hz)    
        
        if  0 <= rank < total_number_of_polarimeters  #if first "total_number_of_polarimeters" ranks
            rng = CorrNoise.OofRNG(Random.MersenneTwister(seeds[pol_number]), -abs(slope[pol_number]), 1.15e-5, fknee_hz[pol_number], fsamp_hz)
            samples_per_pol = total_time*fsamp_hz
            pol_noise = Float64[CorrNoise.randoof(rng) * σ_k[pol_number] for i in 1:(samples_per_pol)]
        end

        if(!ismissing(comm))
            MPI.Barrier(comm)
        end

        ##### SEND AND RECEIVE #####

        start_idx = 1
        end_idx = 0 

        for i in 1:length(noisechunks_to_send)  #loop on ranks
            cur_rank = i-1
    
            for j in 1:length(noisechunks_to_send[i]) #loop on the noise chunks produced by cur_rank
                start_idx_noise = noisechunks_to_send[i][j].first_idx
                end_idx_noise = noisechunks_to_send[i][j].last_idx
                dest_rank = noisechunks_to_send[i][j].dest_rank

                cur_num_noise_samples = end_idx_noise-start_idx_noise+1
                
                #if rank has to send noise (since it produced it)
                if cur_rank == rank 

                    #if the destination rank is itself, keep noise chunk 
                    if dest_rank == rank 
                        end_idx = start_idx + cur_num_noise_samples - 1
                        noise[start_idx:end_idx] = pol_noise[start_idx_noise:end_idx_noise]
                        start_idx += cur_num_noise_samples
                
                    #otherwise send to the destination rank
                    else 
                        cur_noise_send = pol_noise[start_idx_noise:end_idx_noise]
                        MPI.Send(cur_noise_send, dest_rank , 0, comm)
                    end
                
                #if rank is a destination rank for someone
                elseif dest_rank == rank 

                    cur_noise_rec = Array{Float64}(undef, cur_num_noise_samples)
                    end_idx = start_idx + cur_num_noise_samples -1
                    MPI.Recv!(cur_noise_rec, cur_rank, 0, comm)
                    noise[start_idx:end_idx] = cur_noise_rec
                    start_idx += cur_num_noise_samples 
                end
            
            end
  
        end
    

###################################################################

    ################IF LESS PROCESSES THAN POLARIMETERS################
    else
        if rank == 0
            previous_detector = chunks[1][1].pol_number
            noise = Float64[]  #noise rank 0

            rng = CorrNoise.OofRNG(Random.MersenneTwister(seeds[1]), -abs(slope[1]), 1.15e-5, fknee_hz[1], fsamp_hz)

            for i in 1:length(chunks)   #loop on ranks
                num_noise_samples = baselines_per_process[i]*baseline_length_s*fsamp_hz

                for j in 1:length(chunks[i]) #loop on detectors per rank
                    cur_detector = chunks[i][j].pol_number

                    if cur_detector != previous_detector  #if new detector generate new noise
                        rng = CorrNoise.OofRNG(Random.MersenneTwister(seeds[cur_detector]), -abs(slope[cur_detector]), 1.15e-5, fknee_hz[cur_detector], fsamp_hz)
                    end
                    cur_num_noise_samples = chunks[i][j].num_of_elements*baseline_length_s*fsamp_hz
                    cur_noise = Float64[CorrNoise.randoof(rng) * σ_k[cur_detector] for i in 1:(cur_num_noise_samples)]
                    previous_detector =  cur_detector

                    if (i > 1)  #send to other ranks, not rank 0
                        MPI.Send(cur_noise, i-1, 0, comm)
                    else
                        noise = append!(noise, cur_noise)
                    end
                end   
            end
        else
            noise = Float64[]
            for j in 1:length(chunks[rank+1])
                cur_noise = Array{Float64}(undef, chunks[rank+1][j].num_of_elements*baseline_length_s*fsamp_hz)
                MPI.Recv!(cur_noise, 0, 0, comm)
                noise = append!(noise, cur_noise)
            end
        end

    end

    return noise
    

end

